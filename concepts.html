<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>glyph — Concepts</title>
<meta name="description" content="Core concepts behind glyph: layout composition, the render cycle, state binding, viewport scrolling, and more.">
<meta name="keywords" content="go,golang,tui,terminal,ui,framework,layout,composition,render,concepts">
<meta name="author" content="Pete Griffiths">
<meta name="robots" content="index, follow">
<link rel="canonical" href="https://kungfusheep.github.io/glyph-site/concepts.html">
<link rel="sitemap" type="application/xml" href="https://kungfusheep.github.io/glyph-site/sitemap.xml">
<meta name="theme-color" content="#131311">

<!-- open graph -->
<meta property="og:type" content="article">
<meta property="og:title" content="glyph — Concepts">
<meta property="og:description" content="Core concepts behind glyph: layout composition, the render cycle, state binding, viewport scrolling, and more.">
<meta property="og:url" content="https://kungfusheep.github.io/glyph-site/concepts.html">
<meta property="og:site_name" content="glyph">
<meta property="og:locale" content="en_GB">

<!-- twitter -->
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@kungfusheep">
<meta name="twitter:creator" content="@kungfusheep">
<meta name="twitter:title" content="glyph — Concepts">
<meta name="twitter:description" content="Core concepts behind glyph: layout composition, the render cycle, state binding, viewport scrolling, and more.">

<!-- preload -->
<link rel="preload" href="BerkeleyMonoVariable.woff2" as="font" type="font/woff2" crossorigin>
<link rel="stylesheet" href="https://use.typekit.net/rgt4idh.css">

<style>

  @font-face {
    font-family: 'Berkeley Mono';
    src: url('BerkeleyMonoVariable.woff2') format('woff2');
    font-weight: 100 900;
    font-display: swap;
  }

  :root {
    --bg-dark:  #131311;
    --bg-dark2: #1a1a18;
    --bg-dark3: #0e0e0c;
    --rule-dk:  #262624;
    --accent:   #c44040;
    --grad:     linear-gradient(135deg, #c44040 0%, #983848 50%, #682850 100%);
    --mono:  'Berkeley Mono', monospace;
    --akz:   'akzidenz-grotesk-next-pro', sans-serif;
    --din-r: 'din-2014-rounded-variable', sans-serif;
    --s1: 8px; --s2: 16px; --s3: 24px; --s4: 32px;
    --s5: 48px; --s6: 64px; --s7: 80px; --s8: 120px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: var(--bg-dark);
    color: #c8c4b8;
    font-family: var(--mono);
    font-size: 13px;
    line-height: 1.7;
    -webkit-font-smoothing: antialiased;
  }
  ::selection { background: #c8c4b8; color: var(--bg-dark); }

  .page { max-width: 1060px; margin: 0 auto; padding: 48px var(--s5) 0; }

  @media (min-width: 960px) {
    .page { margin-left: 216px; }
    .global-nav-inner { margin-left: 216px; }
  }
  @media (min-width: 1492px) {
    .page { margin-left: auto; }
    .global-nav-inner { margin-left: auto; }
  }

  /* ============================================================
     SECTION
     ============================================================ */
  .concept {
    padding: var(--s7) 0;
    border-bottom: 1px solid var(--rule-dk);
  }
  .concept:last-child { border-bottom: none; }

  .section-head {
    display: flex;
    align-items: flex-start;
    gap: var(--s4);
    margin-bottom: var(--s3);
  }
  .section-num {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 200;
    font-size: 84px;
    line-height: 0.82;
    letter-spacing: -0.04em;
    flex-shrink: 0;
    color: #1e1e1c;
    min-width: 110px;
  }
  .section-meta { padding-top: 8px; }
  .concept-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #444;
    margin-bottom: 4px;
  }
  .concept-title {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 34px;
    color: #e8e4d8;
    letter-spacing: -0.02em;
    line-height: 1.1;
  }
  .concept-prose {
    font-size: 13px;
    color: #888;
    line-height: 1.8;
    max-width: 640px;
    margin-bottom: var(--s4);
  }
  .concept-prose strong {
    color: #c8c4b8;
    font-weight: 400;
  }
  .concept-prose code {
    font-family: var(--mono);
    color: #999;
    font-size: 12px;
  }

  /* ============================================================
     FLOW DIAGRAMS — CSS grid pipeline
     ============================================================ */

  /* horizontal pipeline — use flexbox with forced equal widths via percentage */
  .flow {
    display: flex;
    align-items: stretch;
    gap: 0;
    margin-bottom: var(--s4);
  }
  .flow-node {
    flex: 1 1 0%;
    width: 0;
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    padding: 14px 16px;
    display: flex;
    flex-direction: column;
    gap: 4px;
    overflow: hidden;
  }
  .flow-node-label {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #555;
  }
  .flow-node-name {
    font-size: 13px;
    color: #c8c4b8;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .flow-node-detail {
    font-size: 11px;
    color: #444;
    line-height: 1.5;
  }
  .flow-node.accent {
    border-color: var(--accent);
  }
  .flow-node.accent .flow-node-label {
    color: var(--accent);
  }
  .flow-arrow {
    display: flex;
    align-items: center;
    color: #333;
    font-size: 16px;
    padding: 0 6px;
  }

  /* vertical cascade */
  .cascade {
    display: flex;
    flex-direction: column;
    gap: 2px;
    margin-bottom: var(--s4);
    max-width: 520px;
  }
  .cascade-step {
    display: grid;
    grid-template-columns: 140px 1fr;
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    overflow: hidden;
  }
  .cascade-phase {
    padding: 12px 16px;
    background: rgba(255,255,255,0.015);
    display: flex;
    flex-direction: column;
    justify-content: center;
  }
  .cascade-phase-dir {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #555;
  }
  .cascade-phase-name {
    font-size: 12px;
    color: #c8c4b8;
  }
  .cascade-body {
    padding: 12px 16px;
    font-size: 11px;
    color: #555;
    line-height: 1.5;
    border-left: 1px solid #1e1e1c;
  }
  .cascade-arrow {
    text-align: center;
    color: #333;
    font-size: 14px;
    padding: 2px 0;
  }

  /* cascade sweep animation — shared base styles */
  .cascade-render,
  .cascade-dynamic {
    isolation: isolate;
  }
  .cascade-render .cascade-step,
  .cascade-dynamic .cascade-step {
    position: relative;
    overflow: visible;
    background: var(--bg-dark);
  }

  /* border ring — masked gradient blob */
  .cascade-render .cascade-step::before,
  .cascade-dynamic .cascade-step::before {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 7px;
    padding: 1px;
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    pointer-events: none;
    opacity: var(--sweep-vis);
  }
  /* glow — unmasked blurred blob that follows the same position */
  .cascade-render .cascade-step::after,
  .cascade-dynamic .cascade-step::after {
    content: '';
    position: absolute;
    inset: -8px;
    border-radius: 12px;
    filter: blur(12px);
    pointer-events: none;
    z-index: -1;
    opacity: var(--sweep-vis);
  }

  /* direction label gradient overlay — scaled to match step-relative --sweep */
  .cascade-render .cascade-phase-dir,
  .cascade-dynamic .cascade-phase-dir {
    position: relative;
  }
  .cascade-render .cascade-phase-dir::after,
  .cascade-dynamic .cascade-phase-dir::after {
    content: attr(data-dir);
    position: absolute;
    inset: 0;
    background: radial-gradient(ellipse 300% 800% at 50% calc(var(--sweep) * 4),
      #e85050 0%, #c44040 8%, #983848 14%, #682850 20%, transparent 28%);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    opacity: var(--sweep-vis);
  }

  /* ---- render cycle animations ---- */

  /* downward comet: tight head, exaggerated trailing tail above */
  .cascade-render .sweep-down {
    animation: sweep-down 7s ease-in-out infinite;
  }
  /* shared downward comet gradients */
  .cascade-render .sweep-down::before,
  .cascade-dynamic .sweep-down::before {
    background:
      radial-gradient(ellipse 140% 50% at 50% var(--sweep),
        #e85050 0%, #c44040 18%, #983848 35%, transparent 55%),
      radial-gradient(ellipse 110% 130% at 50% calc(var(--sweep) - 35%),
        rgba(152, 56, 72, 0.55) 0%, rgba(104, 40, 80, 0.28) 40%, transparent 65%),
      radial-gradient(ellipse 80% 260% at 50% calc(var(--sweep) - 85%),
        rgba(104, 40, 80, 0.28) 0%, rgba(80, 30, 60, 0.1) 35%, transparent 55%),
      radial-gradient(ellipse 60% 360% at 50% calc(var(--sweep) - 140%),
        rgba(80, 30, 60, 0.15) 0%, rgba(60, 20, 50, 0.05) 30%, transparent 50%),
      radial-gradient(ellipse 45% 450% at 50% calc(var(--sweep) - 200%),
        rgba(60, 20, 50, 0.08) 0%, rgba(40, 15, 40, 0.02) 30%, transparent 45%);
  }
  .cascade-render .sweep-down::after,
  .cascade-dynamic .sweep-down::after {
    background:
      radial-gradient(ellipse 140% 40% at 50% var(--sweep),
        rgba(232, 80, 80, 0.3) 0%, rgba(196, 64, 64, 0.12) 35%, transparent 60%),
      radial-gradient(ellipse 110% 120% at 50% calc(var(--sweep) - 45%),
        rgba(104, 40, 80, 0.2) 0%, transparent 50%),
      radial-gradient(ellipse 75% 220% at 50% calc(var(--sweep) - 95%),
        rgba(80, 30, 60, 0.12) 0%, transparent 45%),
      radial-gradient(ellipse 55% 300% at 50% calc(var(--sweep) - 150%),
        rgba(60, 20, 50, 0.06) 0%, transparent 40%);
  }

  /* upward comet: tight head, exaggerated trailing tail below */
  .cascade-render .sweep-up {
    animation: sweep-up 7s ease-in-out infinite;
  }
  .cascade-render .sweep-up::before {
    background:
      radial-gradient(ellipse 140% 35% at 50% var(--sweep),
        #e85050 0%, #c44040 18%, #983848 35%, transparent 55%),
      radial-gradient(ellipse 110% 100% at 50% calc(var(--sweep) + 35%),
        rgba(152, 56, 72, 0.55) 0%, rgba(104, 40, 80, 0.28) 40%, transparent 65%),
      radial-gradient(ellipse 80% 200% at 50% calc(var(--sweep) + 85%),
        rgba(104, 40, 80, 0.28) 0%, rgba(80, 30, 60, 0.1) 35%, transparent 55%),
      radial-gradient(ellipse 60% 280% at 50% calc(var(--sweep) + 140%),
        rgba(80, 30, 60, 0.15) 0%, rgba(60, 20, 50, 0.05) 30%, transparent 50%),
      radial-gradient(ellipse 45% 350% at 50% calc(var(--sweep) + 200%),
        rgba(60, 20, 50, 0.08) 0%, rgba(40, 15, 40, 0.02) 30%, transparent 45%);
  }
  .cascade-render .sweep-up::after {
    background:
      radial-gradient(ellipse 140% 40% at 50% var(--sweep),
        rgba(232, 80, 80, 0.3) 0%, rgba(196, 64, 64, 0.12) 35%, transparent 60%),
      radial-gradient(ellipse 110% 120% at 50% calc(var(--sweep) + 45%),
        rgba(104, 40, 80, 0.2) 0%, transparent 50%),
      radial-gradient(ellipse 75% 220% at 50% calc(var(--sweep) + 95%),
        rgba(80, 30, 60, 0.12) 0%, transparent 45%),
      radial-gradient(ellipse 55% 300% at 50% calc(var(--sweep) + 150%),
        rgba(60, 20, 50, 0.06) 0%, transparent 40%);
  }

  /* ---- render cycle stagger ---- */
  .cascade-render .sweep-down {
    animation: sweep-down 7s ease-in-out infinite;
  }
  .cascade-render .cascade-step:nth-child(1) { animation-delay: 0s; }
  .cascade-render .cascade-step:nth-child(3) { animation-delay: 1s; }
  .cascade-render .cascade-step:nth-child(5) { animation-delay: 2s; }
  .cascade-render .cascade-step:nth-child(7) { animation-delay: 3s; }

  @keyframes sweep-down {
    0%        { --sweep: -30%; --sweep-vis: 0; }
    3%        { --sweep-vis: 1; }
    16%       { --sweep-vis: 1; }
    20%       { --sweep: 130%; --sweep-vis: 0; }
    21%, 100% { --sweep: 130%; --sweep-vis: 0; }
  }
  @keyframes sweep-up {
    0%        { --sweep: 130%; --sweep-vis: 0; }
    3%        { --sweep-vis: 1; }
    16%       { --sweep-vis: 1; }
    20%       { --sweep: -30%; --sweep-vis: 0; }
    21%, 100% { --sweep: -30%; --sweep-vis: 0; }
  }

  /* ---- dynamic children: 1-2-3-2-3-2-3 pattern ----
     14s cycle, each sweep ~10% = 1.4s (matching render cycle)
     1: 0-10%  2: 10-20%  3: 20-30%
                2: 30-40%  3: 40-50%
                2: 50-60%  3: 60-70%  rest: 70-100% */

  .cascade-dynamic .cascade-step:nth-child(1) {
    animation: dyn-compile 14s ease-in-out infinite;
  }
  .cascade-dynamic .cascade-step:nth-child(3) {
    animation: dyn-frame 14s ease-in-out infinite;
  }
  .cascade-dynamic .cascade-step:nth-child(5) {
    animation: dyn-render 14s ease-in-out infinite;
  }

  @keyframes dyn-compile {
    0%        { --sweep: -30%; --sweep-vis: 0; }
    2%        { --sweep-vis: 1; }
    8%        { --sweep-vis: 1; }
    10%       { --sweep: 130%; --sweep-vis: 0; }
    11%, 100% { --sweep: 130%; --sweep-vis: 0; }
  }

  @keyframes dyn-frame {
    0%, 9%    { --sweep: -30%; --sweep-vis: 0; }
    10%       { --sweep: -30%; --sweep-vis: 0; }
    12%       { --sweep-vis: 1; }
    18%       { --sweep-vis: 1; }
    20%       { --sweep: 130%; --sweep-vis: 0; }

    29%       { --sweep: -30%; --sweep-vis: 0; }
    30%       { --sweep: -30%; --sweep-vis: 0; }
    32%       { --sweep-vis: 1; }
    38%       { --sweep-vis: 1; }
    40%       { --sweep: 130%; --sweep-vis: 0; }

    49%       { --sweep: -30%; --sweep-vis: 0; }
    50%       { --sweep: -30%; --sweep-vis: 0; }
    52%       { --sweep-vis: 1; }
    58%       { --sweep-vis: 1; }
    60%       { --sweep: 130%; --sweep-vis: 0; }

    61%, 100% { --sweep: 130%; --sweep-vis: 0; }
  }

  @keyframes dyn-render {
    0%, 19%   { --sweep: -30%; --sweep-vis: 0; }
    20%       { --sweep: -30%; --sweep-vis: 0; }
    22%       { --sweep-vis: 1; }
    28%       { --sweep-vis: 1; }
    30%       { --sweep: 130%; --sweep-vis: 0; }

    39%       { --sweep: -30%; --sweep-vis: 0; }
    40%       { --sweep: -30%; --sweep-vis: 0; }
    42%       { --sweep-vis: 1; }
    48%       { --sweep-vis: 1; }
    50%       { --sweep: 130%; --sweep-vis: 0; }

    59%       { --sweep: -30%; --sweep-vis: 0; }
    60%       { --sweep: -30%; --sweep-vis: 0; }
    62%       { --sweep-vis: 1; }
    68%       { --sweep-vis: 1; }
    70%       { --sweep: 130%; --sweep-vis: 0; }

    71%, 100% { --sweep: 130%; --sweep-vis: 0; }
  }

  /* stack diagram */
  .stack {
    display: flex;
    flex-direction: column;
    gap: 0;
    margin-bottom: var(--s4);
    max-width: 400px;
    padding-bottom: 1px;
  }
  .stack-frame {
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: -1px;
  }
  .stack-frame:first-child {
    border-color: var(--accent);
  }
  .stack-frame-name {
    font-size: 12px;
    color: #c8c4b8;
  }
  .stack-frame:first-child .stack-frame-name {
    color: #e8e4d8;
  }
  .stack-frame-hint {
    font-size: 10px;
    color: #444;
  }
  .stack-frame:first-child .stack-frame-hint {
    color: var(--accent);
  }

  /* buffer/viewport diagram */
  .viewport-diagram {
    display: grid;
    grid-template-columns: auto 1fr;
    gap: var(--s3);
    align-items: start;
    margin-bottom: var(--s4);
    max-width: 520px;
  }
  .buffer-col {
    display: flex;
    flex-direction: column;
    gap: 0;
  }
  .buffer-row {
    font-size: 11px;
    padding: 3px 12px;
    border: 1px solid #1e1e1c;
    margin-bottom: -1px;
    color: #444;
    white-space: nowrap;
  }
  .buffer-row.visible {
    color: #c8c4b8;
    background: rgba(152, 56, 72, 0.04);
    position: relative;
    z-index: 1;
  }
  #vp-viewport .buffer-row {
    margin-bottom: 0;
  }
  #vp-viewport .buffer-row + .buffer-row {
    border-top: none;
  }
  .buffer-row:empty::after {
    content: '\00a0';
  }
  .buffer-label {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #444;
    padding: 4px 0;
  }
  .buffer-label.accent { color: var(--accent); }

  /* code blocks */
  .code {
    background: var(--bg-dark3);
    border: 1px solid var(--rule-dk);
    padding: var(--s3);
    font-family: var(--mono);
    font-size: 12px;
    line-height: 1.8;
    margin: var(--s3) 0;
    overflow-x: auto;
    color: #999;
    white-space: pre;
    tab-size: 4;
    border-radius: 8px;
  }
  .code .kw  { color: #d47080; }
  .code .fn  { color: #eeeee4; }
  .code .str { color: #d4887a; }
  .code .cm  { color: #444; }
  .code .tp  { color: #a088b8; }
  .code .nr  { color: #c488a8; }

  /* key path diagram — horizontal flow with key labels */
  .keypath {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: var(--s4);
    flex-wrap: wrap;
  }
  .keypath-key {
    font-family: var(--mono);
    font-size: 12px;
    padding: 6px 12px;
    border: 1px solid #333;
    border-radius: 4px;
    color: #c8c4b8;
    background: rgba(255,255,255,0.02);
    white-space: nowrap;
  }
  .keypath-arrow {
    color: #333;
    font-size: 14px;
  }
  .keypath-label {
    font-size: 10px;
    color: #555;
  }

  /* ============================================================
     BOX MODEL DIAGRAM
     ============================================================ */
  .boxmodel {
    margin-bottom: var(--s4);
    max-width: 560px;
  }
  .boxmodel-container {
    border: 1px dashed #333;
    border-radius: 6px;
    padding: 12px;
    position: relative;
  }
  .boxmodel-margin-label {
    position: absolute;
    top: -18px;
    left: 12px;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #555;
  }
  .boxmodel-margin {
    background: rgba(196, 64, 64, 0.06);
    border: 1px solid rgba(196, 64, 64, 0.15);
    border-radius: 4px;
    padding: 28px 16px 16px;
    position: relative;
  }
  .boxmodel-margin > .bm-label {
    position: absolute;
    top: 3px;
    left: 8px;
    font-size: 9px;
    color: var(--accent);
    opacity: 0.6;
  }
  .boxmodel-border {
    border: 2px solid #444;
    border-radius: 4px;
    padding: 0;
    position: relative;
  }
  .boxmodel-border > .bm-label {
    position: absolute;
    top: -9px;
    left: 10px;
    font-size: 9px;
    color: #666;
    background: var(--bg-dark);
    padding: 0 4px;
  }
  .boxmodel-border-title {
    font-size: 10px;
    color: #888;
    padding: 2px 8px;
    border-bottom: 1px solid #333;
    background: rgba(255,255,255,0.02);
  }
  .boxmodel-content {
    padding: 8px;
  }
  .boxmodel-child {
    background: rgba(255,255,255,0.03);
    border: 1px solid #1e1e1c;
    border-radius: 3px;
    padding: 10px 12px;
    font-size: 11px;
    color: #888;
  }
  .boxmodel-child + .boxmodel-child {
    margin-top: 0;
  }
  .boxmodel-gap {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 2px 0;
  }
  .boxmodel-gap-line {
    font-size: 9px;
    color: #d47080;
    letter-spacing: 0.04em;
  }

  /* grow diagram */
  .grow-diagram {
    display: flex;
    flex-direction: column;
    margin-bottom: var(--s4);
    max-width: 360px;
    height: 220px;
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    overflow: hidden;
  }
  .grow-slot {
    display: flex;
    align-items: center;
    padding: 0 12px;
    font-size: 11px;
    border-bottom: 1px solid #1e1e1c;
    min-height: 0;
  }
  .grow-slot:last-child { border-bottom: none; }
  .grow-slot.fixed {
    flex: 0 0 auto;
    padding: 6px 12px;
    background: rgba(255,255,255,0.03);
    color: #666;
  }
  .grow-slot.flex {
    flex: 1;
    background: rgba(196, 64, 64, 0.06);
    color: var(--accent);
  }
  .grow-slot-name {
    flex: 1;
  }
  .grow-slot-hint {
    font-size: 9px;
    color: #444;
    margin-left: 8px;
  }
  .grow-hbox {
    display: flex;
    flex: 1;
    min-height: 0;
  }
  .grow-hbox .grow-slot {
    flex-direction: column;
    align-items: flex-start;
    justify-content: center;
    border-bottom: none;
    border-right: 1px solid #1e1e1c;
  }
  .grow-hbox .grow-slot:last-child { border-right: none; }
  .grow-hbox .grow-slot-hint {
    margin-left: 0;
    margin-top: 4px;
  }

  /* hbox vs vbox side-by-side */
  .layout-compare {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--s3);
    margin-bottom: var(--s4);
    max-width: 560px;
  }
  .layout-compare-col {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .layout-compare-label {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #555;
  }
  .lc-vbox {
    display: flex;
    flex-direction: column;
    gap: 4px;
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    padding: 8px;
  }
  .lc-hbox {
    display: flex;
    gap: 4px;
    border: 1px solid #1e1e1c;
    border-radius: 6px;
    padding: 8px;
  }
  .lc-item {
    background: rgba(255,255,255,0.04);
    border: 1px solid #2a2a28;
    border-radius: 3px;
    padding: 6px 10px;
    font-size: 10px;
    color: #888;
    text-align: center;
  }
  .lc-hbox .lc-item { flex: 1; }

  /* ============================================================
     SIDE NAV — desktop
     ============================================================ */
  /* ============================================================
     GLOBAL NAV
     ============================================================ */
  .global-nav {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 200;
    height: 48px;
    display: flex;
    align-items: center;
    background: rgba(19, 19, 17, 0.95);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--rule-dk);
  }
  .global-nav-inner {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 1060px;
    margin: 0 auto;
    padding: 0 var(--s5);
  }
  .global-nav-brand {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 400;
    font-size: 18px;
    color: #e8e4d8;
    text-decoration: none;
    letter-spacing: -0.02em;
  }
  .global-nav-links {
    display: flex;
    gap: var(--s3);
    list-style: none;
  }
  .global-nav-links a {
    font-family: var(--mono);
    font-weight: 700;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #555;
    text-decoration: none;
    transition: color 0.15s;
  }
  .global-nav-links a:hover { color: #e8e4d8; }
  .global-nav-links a.active { color: #e8e4d8; }

  .sidenav {
    position: fixed;
    top: 48px;
    left: max(0px, calc(50vw - 746px));
    width: 200px;
    height: calc(100vh - 48px);
    padding: var(--s5) var(--s3) var(--s3) var(--s3);
    display: flex;
    flex-direction: column;
    gap: 0;
    z-index: 100;
  }
  .sidenav-link {
    font-family: var(--mono);
    font-weight: 700;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    color: #333;
    text-decoration: none;
    padding: 8px 0 8px 14px;
    border-left: 2px solid transparent;
    transition: color 0.2s, border-color 0.2s;
    line-height: 1.3;
  }
  .sidenav-link:hover {
    color: #666;
  }
  .sidenav-link.active {
    color: #c8c4b8;
    border-left-color: var(--accent);
  }


  /* ============================================================
     TOP NAV — mobile
     ============================================================ */
  .topnav {
    display: none;
  }

  @media (max-width: 959px) {
    .sidenav { display: none; }

    .topnav {
      display: flex;
      position: sticky;
      top: 48px;
      z-index: 100;
      background: var(--bg-dark);
      border-bottom: 1px solid var(--rule-dk);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
      gap: 0;
      padding: 0 var(--s2);
    }
    .topnav::-webkit-scrollbar { display: none; }
    .topnav-link {
      font-family: var(--mono);
      font-weight: 700;
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #444;
      text-decoration: none;
      padding: 12px 12px;
      white-space: nowrap;
      border-bottom: 2px solid transparent;
      transition: color 0.2s, border-color 0.2s;
      flex-shrink: 0;
    }
    .topnav-link:hover { color: #888; }
    .topnav-link.active {
      color: #c8c4b8;
      border-bottom-color: var(--accent);
    }
  }

  @media (max-width: 768px) {
    .global-nav-inner { padding: 0 var(--s3); }
    .section-head { flex-direction: column; gap: var(--s2); }
    .section-num { font-size: 48px; min-width: auto; }
    .hero-install { font-size: 11px; padding: 10px 14px; max-width: 100%; }
    .install-section { overflow: visible; }
    .start-links { flex-direction: column; gap: var(--s2); }
    .hero-install::before { animation: pulse-thicken 8s ease-in-out infinite, spin 3s linear infinite; }
    .hero-install::after { animation: pulse-glow-dk 8s ease-in-out infinite, spin 3s linear infinite; }
  }

  @media (max-width: 768px) {
    .flow { flex-direction: column; }
    .flow-node { width: auto; }
    .flow-arrow { transform: rotate(90deg); padding: 4px 0; justify-content: center; }
    .cascade-step { grid-template-columns: 1fr; }
    .cascade-body { border-left: none; border-top: 1px solid #1e1e1c; }
    .viewport-diagram { grid-template-columns: 1fr; }
    .layout-compare { grid-template-columns: 1fr; }
  }

  /* footer */
  footer {
    padding: var(--s7) 0 var(--s5);
    border-top: 1px solid #1e1e1c;
    text-align: center;
  }

  .footer-brand {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 400;
    font-size: 18px;
    color: #c8c4b8;
    letter-spacing: -0.02em;
    margin-bottom: var(--s2);
  }

  .footer-links {
    display: flex;
    justify-content: center;
    gap: var(--s3);
    font-family: var(--mono);
    font-weight: 700;
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.06em;
  }

  .footer-links a {
    color: #444;
    text-decoration: none;
    transition: color 0.2s;
  }

  .footer-links a:hover { color: #c8c4b8; }

  /* hero install */
  @property --angle {
    syntax: '<angle>';
    initial-value: 135deg;
    inherits: false;
  }

  @property --sweep {
    syntax: '<percentage>';
    initial-value: -30%;
    inherits: true;
  }

  @property --sweep-vis {
    syntax: '<number>';
    initial-value: 0;
    inherits: true;
  }

  @keyframes spin {
    from { --angle: 135deg; }
    to { --angle: 495deg; }
  }

  @keyframes pulse-thicken {
    0%, 100% { inset: -1px; padding: 1px; border-radius: 7px; }
    12% { inset: -2px; padding: 2px; border-radius: 8px; }
    25% { inset: -1px; padding: 1px; border-radius: 7px; }
  }

  @keyframes pulse-glow-dk {
    0%, 100% { opacity: 0; }
    12% { opacity: 0.25; }
    25% { opacity: 0; }
  }

  .hero-install {
    display: inline-flex;
    align-items: center;
    gap: 16px;
    background: var(--bg-dark3);
    color: #c8c4b8;
    padding: 12px 20px;
    font-family: var(--mono);
    font-size: 13px;
    letter-spacing: 0.01em;
    border-radius: 6px;
    cursor: pointer;
    position: relative;
  }

  .hero-install:hover { background: #111; }

  .hero-install .prompt { color: #555; user-select: none; }

  .hero-install .copied {
    font-size: 11px;
    color: #e8e4d8;
    margin-left: 16px;
    opacity: 0;
    transition: opacity 0.15s;
  }

  .hero-install .copied.show { opacity: 1; }

  .hero-install::before {
    content: '';
    position: absolute;
    inset: -1px;
    border-radius: 7px;
    padding: 1px;
    background: conic-gradient(from var(--angle), #c44040, #e85050, #983848, #682850, #e85050, #c44040);
    -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    -webkit-mask-composite: xor;
    mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
    mask-composite: exclude;
    opacity: 1;
    animation: spin 3s linear infinite;
    transition: opacity 0.4s, inset 0.4s, padding 0.4s, border-radius 0.4s;
    pointer-events: none;
  }

  .hero-install::after {
    content: '';
    position: absolute;
    inset: -8px;
    border-radius: 14px;
    background: conic-gradient(from var(--angle), #c44040, #e85050, #983848, #682850, #e85050, #c44040);
    filter: blur(20px);
    opacity: 0;
    transition: opacity 0.4s;
    pointer-events: none;
    z-index: -1;
  }

  .hero-install:hover::before,
  .hero-install:hover::after {
    animation: spin 3s linear infinite;
  }

  .hero-install:hover::before {
    inset: -2px;
    border-radius: 8px;
    padding: 2px;
  }

  .hero-install:hover::after {
    opacity: 0.25;
  }

  .install-section {
    padding: 48px 0;
    border-top: 1px solid #1e1e1c;
    isolation: isolate;
  }

  .install-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #444;
    margin-bottom: 4px;
  }

  .install-title {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 34px;
    color: #e8e4d8;
    letter-spacing: -0.02em;
    line-height: 1.1;
    margin-bottom: 24px;
  }

  .start-links {
    display: flex;
    gap: 48px;
    padding: 32px 0 0;
  }

  .start-links a {
    font-size: 12px;
    color: #c8c4b8;
    text-decoration: none;
    border-bottom: 1px solid #333;
    padding-bottom: 2px;
    transition: border-color 0.15s;
  }

  .start-links a:hover { border-color: #c8c4b8; }

  /* gradient accent */
  .flow-node.accent {
    border-color: transparent;
    background-origin: border-box;
    background-clip: padding-box, border-box;
    background-image: linear-gradient(var(--bg-dark), var(--bg-dark)), var(--grad);
  }
  .flow-node.accent .flow-node-label,
  .stack-frame:first-child .stack-frame-hint,
  .buffer-label.accent,
  .boxmodel-margin > .bm-label {
    background: var(--grad);
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  .stack-frame:first-child {
    border-color: transparent;
    background-origin: border-box;
    background-clip: padding-box, border-box;
    background-image: linear-gradient(var(--bg-dark), var(--bg-dark)), var(--grad);
    position: relative;
    z-index: 1;
  }
  .buffer-row.visible {
    border-color: var(--accent);
  }
  .sidenav-link.active { border-image: var(--grad) 1; }
  .topnav-link.active { border-image: var(--grad) 1; }

</style>
</head>
<body>

<nav class="global-nav">
  <div class="global-nav-inner">
    <a href="index.html" class="global-nav-brand">glyph</a>
    <ul class="global-nav-links">
      <li><a href="index.html">Home</a></li>
      <li><a href="concepts.html" class="active">Concepts</a></li>
      <li><a href="api.html">API</a></li>

      <li><a href="https://github.com/kungfusheep/glyph">GitHub</a></li>
    </ul>
  </div>
</nav>

<nav class="sidenav">
  <a href="#build" class="sidenav-link">Build & Execute</a>
  <a href="#render" class="sidenav-link">Render Cycle</a>
  <a href="#layout" class="sidenav-link">Layout Properties</a>
  <a href="#pointers" class="sidenav-link">Pointer Semantics</a>
  <a href="#dynamic" class="sidenav-link">Dynamic Children</a>
  <a href="#input" class="sidenav-link">Input Handling</a>
  <a href="#jump" class="sidenav-link">Jump Labels</a>
  <a href="#routing" class="sidenav-link">Routing & Views</a>
  <a href="#layers" class="sidenav-link">Layers & Scrolling</a>
</nav>

<nav class="topnav">
  <a href="#build" class="topnav-link">Build</a>
  <a href="#render" class="topnav-link">Render</a>
  <a href="#layout" class="topnav-link">Layout</a>
  <a href="#pointers" class="topnav-link">Pointers</a>
  <a href="#dynamic" class="topnav-link">Dynamic</a>
  <a href="#input" class="topnav-link">Input</a>
  <a href="#jump" class="topnav-link">Jump</a>
  <a href="#routing" class="topnav-link">Routing</a>
  <a href="#layers" class="topnav-link">Layers</a>
</nav>

<div class="page">

<!-- ============================================================
     1. BUILD & EXECUTE
     ============================================================ -->
<div class="concept" id="build">
  <div class="section-head">
    <div class="section-num">01</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Build & Execute</div>
    </div>
  </div>

  <div class="concept-prose">
    Every glyph view goes through two distinct phases. <strong>Build</strong> happens once
    when you call <code>SetView()</code> — the declarative tree is compiled into a flat array
    of operations via reflection and type switches. <strong>Execute</strong> happens every frame —
    it walks the compiled ops and dereferences pointers to read current state. No tree rebuilds,
    no diffing, no allocation in steady state.
  </div>

  <div class="flow">
    <div class="flow-node accent">
      <div class="flow-node-label">Once</div>
      <div class="flow-node-name">SetView()</div>
      <div class="flow-node-detail">declarative tree in</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node accent">
      <div class="flow-node-label">Compile</div>
      <div class="flow-node-name">compile()</div>
      <div class="flow-node-detail">~50 type switch, reflection</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Store</div>
      <div class="flow-node-name">[]Op + []Geom</div>
      <div class="flow-node-detail">flat arrays, pointer offsets</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Each frame</div>
      <div class="flow-node-name">Execute()</div>
      <div class="flow-node-detail">deref pointers → buffer</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Flush</div>
      <div class="flow-node-name">Screen.Flush()</div>
      <div class="flow-node-detail">diff → single syscall</div>
    </div>
  </div>

  <div class="concept-prose">
    The composable API surface — <code>VBox.Gap(2).Border(BorderRounded)</code> — is purely
    a build-time convenience. At runtime, the template is just a flat array walk with pointer reads.
    Values exist in three variants: <strong>static</strong> (embedded literal),
    <strong>pointer</strong> (dereferenced each frame), and <strong>offset</strong>
    (ForEach element base + unsafe.Pointer arithmetic).
  </div>

  <div class="code code-raw">SetView(                        // build: compiled once
    VBox.Gap(2).Border(BorderRounded)(
        Text(&title),              // pointer: read each frame
        Text("static label"),       // static: embedded in op
    ),
)</div>
</div>

<!-- ============================================================
     2. RENDER CYCLE
     ============================================================ -->
<div class="concept" id="render">
  <div class="section-head">
    <div class="section-num">02</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Render Cycle</div>
    </div>
  </div>

  <div class="concept-prose">
    Rendering is a four-phase pipeline that runs on every frame, heavily optimised for terminal
    workloads. Each phase operates directly on flat <strong>Op</strong> and <strong>Geom</strong>
    arrays — no tree rebuilds, no node allocation. Components outside the viewport are culled
    before rendering, and the final flush diffs against the previous frame to emit only the
    cells that actually changed.
  </div>

  <div class="cascade cascade-render">
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="↓ top-down">↓ top-down</div>
        <div class="cascade-phase-name">Width Distribution</div>
      </div>
      <div class="cascade-body">
        Parent distributes available width to children. Fixed widths and percentages first,
        then remaining space split by flex grow. HBox horizontal flex is fully resolved here.
      </div>
    </div>
    <div class="cascade-arrow">↓</div>
    <div class="cascade-step sweep-up">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="↑ bottom-up">↑ bottom-up</div>
        <div class="cascade-phase-name">Layout</div>
      </div>
      <div class="cascade-body">
        Deepest nodes first. Leaf nodes measure content height; containers sum children
        plus gaps, borders, margin. Each node saves its natural <code>ContentH</code> before
        any flex expansion.
      </div>
    </div>
    <div class="cascade-arrow">↓</div>
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="↓ top-down">↓ top-down</div>
        <div class="cascade-phase-name">Flex Grow</div>
      </div>
      <div class="cascade-body">
        Children with <code>Grow()</code> expand along the parent's main axis to fill remaining
        space — vertically in a VBox, horizontally in an HBox. Siblings are repositioned to
        account for the new sizes.
      </div>
    </div>
    <div class="cascade-arrow">↓</div>
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="↓ top-down">↓ top-down</div>
        <div class="cascade-phase-name">Render</div>
      </div>
      <div class="cascade-body">
        Walk the ops from root, write cells to the buffer at computed absolute positions.
        Borders, text, fills — one pass with final x/y/w/h coordinates.
      </div>
    </div>
  </div>

  <div class="concept-prose">
    Flex grow is a separate phase because it needs the parent's final size, which flows top-down
    from the screen dimensions. <code>layout()</code> runs once, saves each node's natural size,
    and flex grow distributes the remaining space without re-running layout.
  </div>
</div>

<!-- ============================================================
     3. LAYOUT PROPERTIES
     ============================================================ -->
<div class="concept" id="layout">
  <div class="section-head">
    <div class="section-num">03</div>
    <div class="section-meta">
      <div class="concept-label">Visual</div>
      <div class="concept-title">Layout Properties</div>
    </div>
  </div>

  <div class="concept-prose">
    The spatial properties that control how components are sized and positioned.
  </div>

  <!-- VBox vs HBox -->
  <div class="layout-compare">
    <div class="layout-compare-col">
      <div class="layout-compare-label">VBox — vertical</div>
      <div class="lc-vbox">
        <div class="lc-item">Child A</div>
        <div class="lc-item">Child B</div>
        <div class="lc-item">Child C</div>
      </div>
    </div>
    <div class="layout-compare-col">
      <div class="layout-compare-label">HBox — horizontal</div>
      <div class="lc-hbox">
        <div class="lc-item">A</div>
        <div class="lc-item">B</div>
        <div class="lc-item">C</div>
      </div>
    </div>
  </div>

  <!-- Box model: Margin → Border → Content -->
  <div class="concept-prose">
    <strong>Margin</strong> is outside the border — the space between this component and its siblings.
    <strong>Border</strong> wraps the content area. <strong>Gap</strong> is the spacing a container
    inserts between its children.
  </div>

  <div class="boxmodel">
    <div class="boxmodel-container">
      <div class="boxmodel-margin-label">parent container</div>
      <div class="boxmodel-margin">
        <span class="bm-label">margin</span>
        <div class="boxmodel-border">
          <span class="bm-label">border</span>
          <div class="boxmodel-border-title">Title</div>
          <div class="boxmodel-content">
            <div class="boxmodel-child">Text("hello")</div>
            <div class="boxmodel-gap"><span class="boxmodel-gap-line">↕ gap</span></div>
            <div class="boxmodel-child">Text("world")</div>
            <div class="boxmodel-gap"><span class="boxmodel-gap-line">↕ gap</span></div>
            <div class="boxmodel-child">Text("!")</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="code code-raw">VBox.Margin(1).Border(BorderRounded).Title("Title").Gap(1)(
    Text("hello"),
    Text("world"),
    Text("!"),
)</div>

  <!-- Grow -->
  <div class="concept-prose">
    <strong>Grow</strong> controls how remaining space is distributed after fixed-size children
    are measured. Without <code>Grow()</code>, a component takes exactly its content size.
    With it, the component expands into whatever space is left over. The number you pass is
    a <strong>ratio</strong>, not a pixel value.
  </div>

  <div class="concept-prose">
    <strong>One child with Grow(1)</strong> — it gets all the remaining space:
  </div>

  <div class="grow-diagram">
    <div class="grow-slot fixed">
      <span class="grow-slot-name">Text("header")</span>
      <span class="grow-slot-hint">1 row</span>
    </div>
    <div class="grow-slot flex">
      <span class="grow-slot-name">List(&amp;items).Grow(1)</span>
      <span class="grow-slot-hint">all remaining</span>
    </div>
    <div class="grow-slot fixed">
      <span class="grow-slot-name">Text("footer")</span>
      <span class="grow-slot-hint">1 row</span>
    </div>
  </div>

  <div class="code code-raw">VBox(
    Text("header"),
    List(&items).Grow(1),
    Text("footer"),
)</div>

  <div class="concept-prose">
    <strong>Two children with equal Grow(1)</strong> — they split the remaining space 50/50:
  </div>

  <div class="grow-diagram">
    <div class="grow-slot fixed">
      <span class="grow-slot-name">Text("header")</span>
      <span class="grow-slot-hint">1 row</span>
    </div>
    <div class="grow-slot flex" style="flex: 1;">
      <span class="grow-slot-name">List(&amp;items).Grow(1)</span>
      <span class="grow-slot-hint">50%</span>
    </div>
    <div class="grow-slot flex" style="flex: 1;">
      <span class="grow-slot-name">LayerView(&amp;log).Grow(1)</span>
      <span class="grow-slot-hint">50%</span>
    </div>
  </div>

  <div class="code code-raw">VBox(
    Text("header"),
    List(&items).Grow(1),
    LayerView(&log).Grow(1),
)</div>

  <div class="concept-prose">
    <strong>Unequal ratios — Grow(1) vs Grow(2)</strong> — the space is split proportionally.
    Grow(2) gets twice as much of the remaining space as Grow(1):
  </div>

  <div class="grow-diagram grow-diagram-split">
    <div class="grow-slot fixed">
      <span class="grow-slot-name">Text("header")</span>
      <span class="grow-slot-hint">1 row</span>
    </div>
    <div class="grow-hbox">
      <div class="grow-slot flex" style="flex: 1;">
        <span class="grow-slot-name">sidebar.Grow(1)</span>
        <span class="grow-slot-hint">⅓</span>
      </div>
      <div class="grow-slot flex" style="flex: 2;">
        <span class="grow-slot-name">content.Grow(2)</span>
        <span class="grow-slot-hint">⅔</span>
      </div>
    </div>
  </div>

  <div class="code code-raw">VBox(
    Text("header"),
    HBox.Grow(1)(
        sidebar.Grow(1),            // 1 part
        content.Grow(2),            // 2 parts
    ),
)</div>

  <div class="concept-prose">
    The number doesn't mean anything on its own — <code>Grow(1)</code> and <code>Grow(1)</code>
    is the same split as <code>Grow(100)</code> and <code>Grow(100)</code>. It's the ratio between
    siblings that matters. Think of it as "parts of the remaining pie."
  </div>

  <div class="concept-prose">
    <code>FitContent()</code> is the inverse — it tells a container to shrink to its
    children's measured size instead of filling available space.
    <code>WidthPct(0.5)</code> sets width as a fraction of the parent.
    <code>Size(w, h)</code> sets both dimensions explicitly.
  </div>
</div>

<!-- ============================================================
     4. POINTER SEMANTICS
     ============================================================ -->
<div class="concept" id="pointers">
  <div class="section-head">
    <div class="section-num">04</div>
    <div class="section-meta">
      <div class="concept-label">Core</div>
      <div class="concept-title">Pointer Semantics</div>
    </div>
  </div>

  <div class="concept-prose">
    There's no reactivity in glyph. No subscriptions, no signals, no observers, no change detection.
    When the framework renders, it dereferences your pointers and reads whatever value is there right now.
    That's it.
  </div>

  <div class="code code-raw">title := "Hello"

app.SetView(Text(&title))    // captures the pointer, not the value

title = "World"               // next render shows "World"</div>

  <div class="concept-prose">
    Pass a <code>*string</code> and the text updates when the string changes. Pass a <code>string</code>
    literal and it's static forever. Same pattern for <code>*int</code>, <code>*bool</code>,
    <code>*[]T</code> — anything behind a pointer is live, anything without one is baked in at compile.
  </div>

  <div class="concept-prose">
    There's no state diffing, no change detection. You mutate your variables directly, and the
    next render reads current values through pointers. Renders happen when you return from a key
    handler, or when you call <code>RequestRender()</code> from a goroutine. That's the whole model.
  </div>

  <div class="concept-prose">
    This sidesteps an entire category of problems - render thrashing, cascading updates, glitchy intermediate states from identity-change confusion. None of that can happen here because there's no propagation mechanism to misfire.

    Nothing stops you building reactive patterns on top - an observer that calls <code>RequestRender()</code> when a channel
    fires is a few lines of code. glyph just doesn't ship that complexity by default.
  </div>
</div>

<!-- ============================================================
     5. DYNAMIC CHILDREN
     ============================================================ -->
<div class="concept" id="dynamic">
  <div class="section-head">
    <div class="section-num">05</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Dynamic Children</div>
    </div>
  </div>

  <div class="concept-prose">
    ForEach, If, and Switch each compile to <strong>exactly one Op</strong> in the parent's flat array.
    Their content lives in separate sub-templates — self-contained <code>*Template</code> instances
    with their own <code>ops</code>, <code>geom</code>, and <code>byDepth</code> arrays.
    From the parent's perspective, they're opaque single-slot ops.
  </div>

  <div class="flow">
    <div class="flow-node accent">
      <div class="flow-node-label">Parent ops[]</div>
      <div class="flow-node-name">... OpText OpForEach OpText ...</div>
      <div class="flow-node-detail">one slot per dynamic node</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Sub-template</div>
      <div class="flow-node-name">own ops[] + geom[] + byDepth</div>
      <div class="flow-node-detail">self-contained mini-template</div>
    </div>
  </div>

  <div class="concept-prose">
    <strong>ForEach</strong> is the most interesting. The render function is called once at compile time
    against a <strong>dummy element</strong>. Any pointers into that dummy get converted to offset-based
    ops via <code>unsafe.Pointer</code> arithmetic — the offset from the element base address to the
    field pointer is stored instead of the pointer itself.
  </div>

  <div class="cascade cascade-dynamic">
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="compile">compile</div>
        <div class="cascade-phase-name">Dummy element</div>
      </div>
      <div class="cascade-body">
        Create a temp <code>T</code>, call render function once. Pointers within the dummy's
        memory range become <code>OpTextOff</code> with offset = <code>ptr - dummyBase</code>.
        One sub-template compiled, shared across all items.
      </div>
    </div>
    <div class="cascade-arrow">↓</div>
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="each frame">each frame</div>
        <div class="cascade-phase-name">Layout per item</div>
      </div>
      <div class="cascade-body">
        Read live slice header (<code>Data</code>, <code>Len</code>) via <code>unsafe.Pointer</code>.
        For each item: swap <code>elemBase</code> to the real element, run
        <code>distributeWidths</code> + <code>layout</code> on the sub-template.
        Store position in <code>iterGeoms[i]</code> — the sub-template's geom is scratch.
      </div>
    </div>
    <div class="cascade-arrow">↓</div>
    <div class="cascade-step sweep-down">
      <div class="cascade-phase">
        <div class="cascade-phase-dir" data-dir="render">render</div>
        <div class="cascade-phase-name">Offset resolve</div>
      </div>
      <div class="cascade-body">
        <code>OpTextOff</code> resolves to <code>(*string)(elemBase + offset)</code>
        for each element. Same compiled template, different data. Per-item positions
        read from <code>iterGeoms</code>.
      </div>
    </div>
  </div>

  <div class="concept-prose">
    <strong>If</strong> compiles both branches into separate sub-templates at build time. At runtime
    the condition is evaluated and only the active branch is laid out and rendered. The inactive branch
    costs nothing — it's not even visited.
  </div>

  <div class="concept-prose">
    <strong>Switch</strong> creates N+1 sub-templates (one per case + default).
    <code>getMatchIndex()</code> linear-scans to find the matching case. Only the winner
    is laid out.
  </div>

  <div class="concept-prose">
    None of these participate in the parent's <code>byDepth</code> layout pass directly.
    They're measured inline by their parent container when it encounters them during the child scan
    in <code>layoutContainer</code>. The sub-templates run their own complete layout pipeline
    internally — <code>distributeWidths</code> + <code>layout</code> — but this is scoped
    to the sub-template's own ops array, not the parent's.
  </div>

  <div class="code code-raw">ForEach(&items, func(item *Item) any {
    return HBox.Gap(2)(
        Text(&item.Name),
        Text(&item.Status),
    )
})</div>
</div>

<!-- ============================================================
     6. INPUT HANDLING
     ============================================================ -->
<div class="concept" id="input">
  <div class="section-head">
    <div class="section-num">06</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Input Handling</div>
    </div>
  </div>

  <div class="concept-prose">
    Input is managed by <strong>riffkey</strong>, a router stack that supports vim-style multi-key
    sequences, modal layers, and count prefixes. Components declare their bindings as data via
    <code>BindNav()</code>, <code>BindToggle()</code>, etc. — these are wired at compile time,
    not at runtime.
  </div>

  <div class="concept-prose">
    A keypress follows this path:
  </div>

  <div class="keypath">
    <div class="keypath-key">keystroke</div>
    <div class="keypath-arrow">→</div>
    <div class="keypath-key">Router (top of stack)</div>
    <div class="keypath-arrow">→</div>
    <div class="keypath-key">pattern match</div>
    <div class="keypath-arrow">→</div>
    <div class="keypath-key">handler()</div>
    <div class="keypath-arrow">→</div>
    <div class="keypath-key">render</div>
  </div>

  <div class="concept-prose">
    The router stack enables <strong>modal input</strong>. Push a new router for a dialog;
    it captures all keys. Pop it when done — the previous context resumes exactly where it was.
    Each named view gets its own router, swapped atomically by <code>Go()</code>.
  </div>

  <div class="stack">
    <div class="stack-frame">
      <div class="stack-frame-name">Dialog router</div>
      <div class="stack-frame-hint">← active (captures all keys)</div>
    </div>
    <div class="stack-frame">
      <div class="stack-frame-name">View "editor" router</div>
      <div class="stack-frame-hint">paused</div>
    </div>
    <div class="stack-frame">
      <div class="stack-frame-name">App base router</div>
      <div class="stack-frame-hint">paused</div>
    </div>
  </div>

  <div class="code code-raw">app.Handle("q", app.Stop)          // single key
app.Handle("gg", goToTop)          // multi-key sequence
app.Handle("<C-w>j", focusDown)    // chord + key
app.Handle("dd", deleteItem)       // vim-style with count: 3dd

// modal: push router for confirm dialog
app.Push(confirmRouter)
// ...later
app.Pop()</div>
</div>

<!-- ============================================================
     7. JUMP LABELS
     ============================================================ -->
<div class="concept" id="jump">
  <div class="section-head">
    <div class="section-num">07</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Jump Labels</div>
    </div>
  </div>

  <div class="concept-prose">
    Jump labels bring vim-easymotion to the TUI. Press a trigger key and every jump target
    in the view gets a short label overlay. Type the label and the target's
    <code>onSelect</code> fires. It's a first-class feature — any component can be a target.
  </div>

  <div class="flow">
    <div class="flow-node accent">
      <div class="flow-node-label">Trigger</div>
      <div class="flow-node-name">JumpKey("space")</div>
      <div class="flow-node-detail">enter jump mode</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Render</div>
      <div class="flow-node-name">labels appear</div>
      <div class="flow-node-detail">targets collect, labels assigned</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Select</div>
      <div class="flow-node-name">type "a" → onSelect()</div>
      <div class="flow-node-detail">exit jump mode</div>
    </div>
  </div>

  <div class="concept-prose">
    Wrap any component with <code>Jump()</code> to make it a target. The framework handles
    label assignment and positioning during the render pass.
  </div>

  <div class="code code-raw">app.JumpKey("space")

app.SetView(
    VBox.Gap(1)(
        Jump(Text("Inbox"), func() { section = "inbox" }),
        Jump(Text("Drafts"), func() { section = "drafts" }),
        Jump(Text("Sent"), func() { section = "sent" }),
    ),
)</div>

  <div class="concept-prose">
    <code>app.SetJumpStyle()</code> controls how labels look. For dynamic targets that aren't
    wrapped with <code>Jump()</code>, use <code>app.AddJumpTarget(x, y, onSelect, style)</code>
    during a render callback.
  </div>
</div>

<!-- ============================================================
     8. ROUTING & VIEWS
     ============================================================ -->
<div class="concept" id="routing">
  <div class="section-head">
    <div class="section-num">08</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Routing & Views</div>
    </div>
  </div>

  <div class="concept-prose">
    Applications with multiple screens use <strong>named views</strong>. Each view has its own
    compiled template and its own riffkey router — switching views swaps both atomically.
    No recompilation, no handler cleanup.
  </div>

  <div class="flow">
    <div class="flow-node">
      <div class="flow-node-label">Define</div>
      <div class="flow-node-name">app.View("list", ...)</div>
      <div class="flow-node-detail">template + handlers</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Define</div>
      <div class="flow-node-name">app.View("detail", ...)</div>
      <div class="flow-node-detail">template + handlers</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node accent">
      <div class="flow-node-label">Switch</div>
      <div class="flow-node-name">app.Go("detail")</div>
      <div class="flow-node-detail">swap template + router</div>
    </div>
  </div>

  <div class="concept-prose">
    For overlays and dialogs, <code>PushView()</code> layers a modal on top of the current view.
    The modal's handlers take precedence. <code>PopView()</code> peels it off — the previous
    view and its input context resume immediately.
  </div>

  <div class="stack">
    <div class="stack-frame">
      <div class="stack-frame-name">"confirm" (modal)</div>
      <div class="stack-frame-hint">← PushView</div>
    </div>
    <div class="stack-frame">
      <div class="stack-frame-name">"detail"</div>
      <div class="stack-frame-hint">← Go("detail")</div>
    </div>
    <div class="stack-frame">
      <div class="stack-frame-name">"list"</div>
      <div class="stack-frame-hint">RunFrom("list")</div>
    </div>
  </div>

  <div class="code code-raw">app.View("list", VBox(
    Text("Items"),
    List(&items).BindNav("j", "k"),
)).Handle("n", func() { app.Go("detail") })

app.View("detail", VBox(
    Text(&detail),
)).Handle("b", func() { app.Go("list") })

app.RunFrom("list")</div>
</div>

<!-- ============================================================
     9. LAYERS & SCROLLING
     ============================================================ -->
<div class="concept" id="layers">
  <div class="section-head">
    <div class="section-num">09</div>
    <div class="section-meta">
      <div class="concept-label">System</div>
      <div class="concept-title">Layers & Scrolling</div>
    </div>
  </div>

  <div class="concept-prose">
    When content is taller than the viewport, <strong>Layer</strong> provides a pre-rendered
    off-screen buffer with scroll management. Content is rendered into the full-size buffer once,
    then the visible portion is blitted to the screen each frame. The layer only re-renders
    when the viewport width changes.
  </div>

  <div class="viewport-diagram" id="vp-diagram">
    <div>
      <div class="buffer-label">Buffer</div>
      <div class="buffer-col" id="vp-buffer">
        <div class="buffer-row visible">line 0: package main</div>
        <div class="buffer-row visible">line 1: import . "glyph"</div>
        <div class="buffer-row visible">line 2:</div>
        <div class="buffer-row visible">line 3: func main() {</div>
        <div class="buffer-row">line 4:     app, _ := NewApp()</div>
        <div class="buffer-row">line 5:     app.SetView(</div>
        <div class="buffer-row">line 6:         VBox(</div>
        <div class="buffer-row">line 7:             Text("hello"),</div>
        <div class="buffer-row">line 8:         ),</div>
        <div class="buffer-row">line 9:     )</div>
        <div class="buffer-row">line 10: }</div>
      </div>
    </div>
    <div>
      <div class="buffer-label accent" id="vp-label">Viewport (scroll=0, height=4)</div>
      <div class="buffer-col" id="vp-viewport">
        <div class="buffer-row visible">package main</div>
        <div class="buffer-row visible">import . "glyph"</div>
        <div class="buffer-row visible"></div>
        <div class="buffer-row visible">func main() {</div>
      </div>
      <div style="margin-top: var(--s3);">
        <div class="concept-prose" style="margin:0; max-width: none;">
          <code>ScrollDown(n)</code> / <code>ScrollUp(n)</code> shift the window.
          <code>ScreenCursor()</code> translates buffer coordinates to screen position.
        </div>
      </div>
    </div>
  </div>

  <div class="concept-prose">
    <strong>LogC</strong> extends Layer with an <code>io.Reader</code> that ingests lines in the
    background. Auto-scroll follows new content by default. <strong>FilterLogC</strong> adds
    live fzf-style filtering on top. Both re-render lazily — only when content changes or
    the viewport width changes.
  </div>

  <div class="flow">
    <div class="flow-node">
      <div class="flow-node-label">Write</div>
      <div class="flow-node-name">io.Reader → LogC</div>
      <div class="flow-node-detail">background line ingestion</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Store</div>
      <div class="flow-node-name">Layer buffer</div>
      <div class="flow-node-detail">full content, off-screen</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node accent">
      <div class="flow-node-label">Blit</div>
      <div class="flow-node-name">viewport slice</div>
      <div class="flow-node-detail">visible rows → screen buffer</div>
    </div>
    <div class="flow-arrow">→</div>
    <div class="flow-node">
      <div class="flow-node-label">Flush</div>
      <div class="flow-node-name">diff + write</div>
      <div class="flow-node-detail">only changed cells</div>
    </div>
  </div>

  <div class="code code-raw">layer := NewLayer()
layer.Render = func() {
    buf := layer.Buffer()
    for i, line := range lines {
        buf.WriteString(0, i, line, Style{})
    }
}

app.SetView(VBox(LayerView(layer).Grow(1)))</div>
</div>

</div><!-- .page -->

<div class="page">
  <div class="install-section">
    <div class="install-label">Install</div>
    <div class="install-title">Get Started</div>

    <div class="hero-install" onclick="copyInstall(this)">
      <span class="prompt">$</span>
      go get github.com/kungfusheep/glyph@latest
      <span class="copied">copied</span>
    </div>

    <div class="start-links">
      <a href="index.html">Home &rarr;</a>
      <a href="api.html">Browse the API &rarr;</a>
    </div>
  </div>
</div>

<footer>
  <div class="footer-brand">glyph</div>
  <div class="footer-links">
    <a href="index.html">Home</a>
    <a href="api.html">API</a>
    <a href="concepts.html">Concepts</a>
    <a href="https://github.com/kungfusheep/glyph">Source</a>
  </div>
</footer>

<script>
function copyInstall(el) {
  const cmd = 'go get github.com/kungfusheep/glyph@latest';
  navigator.clipboard.writeText(cmd).then(() => {
    const badge = el.querySelector('.copied');
    badge.classList.add('show');
    setTimeout(() => badge.classList.remove('show'), 1500);
  });
}

// syntax highlighting for code-raw blocks
(function() {
  function esc(s) {
    const d = document.createElement('div');
    d.textContent = s;
    return d.innerHTML;
  }

  function highlightGo(raw) {
    const s = esc(raw);
    const tokens = [];
    let i = 0;
    while (i < s.length) {
      if (s[i] === '"' || s[i] === '`') {
        const q = s[i];
        let j = i + 1;
        while (j < s.length && s[j] !== q) { if (s[j] === '\\' && q === '"') j++; j++; }
        tokens.push({ type: 'str', text: s.slice(i, j + 1) });
        i = j + 1;
      } else if (s.slice(i, i + 4) === '&amp' || s.slice(i, i + 3) === '&lt' || s.slice(i, i + 3) === '&gt') {
        let j = s.indexOf(';', i);
        if (j === -1) j = i;
        tokens.push({ type: 'text', text: s.slice(i, j + 1) });
        i = j + 1;
      } else if (s.slice(i, i + 2) === '//') {
        let j = s.indexOf('\n', i);
        if (j === -1) j = s.length;
        tokens.push({ type: 'cm', text: s.slice(i, j) });
        i = j;
      } else if (/[a-zA-Z_]/.test(s[i])) {
        let j = i;
        while (j < s.length && /[a-zA-Z0-9_]/.test(s[j])) j++;
        tokens.push({ type: 'word', text: s.slice(i, j) });
        i = j;
      } else if (/[0-9]/.test(s[i])) {
        let j = i;
        while (j < s.length && /[0-9.x]/.test(s[j])) j++;
        tokens.push({ type: 'nr', text: s.slice(i, j) });
        i = j;
      } else {
        tokens.push({ type: 'text', text: s[i] });
        i++;
      }
    }

    const kws = new Set(['package','import','func','return','var','const','type','struct',
      'interface','if','else','for','range','switch','case','default','break','continue',
      'go','defer','select','chan','map','true','false','nil','any','error']);
    const types = new Set(['string','int','int8','int16','int32','int64',
      'uint','uint8','uint16','uint32','uint64','float32','float64','bool','byte','rune']);

    return tokens.map((t, idx) => {
      if (t.type === 'str') return `<span class="str">${t.text}</span>`;
      if (t.type === 'cm') return `<span class="cm">${t.text}</span>`;
      if (t.type === 'nr') return `<span class="nr">${t.text}</span>`;
      if (t.type === 'word') {
        if (kws.has(t.text)) return `<span class="kw">${t.text}</span>`;
        if (types.has(t.text)) return `<span class="tp">${t.text}</span>`;
        const next = tokens[idx + 1];
        if (next && (next.text === '(' || next.text === '.')) return `<span class="fn">${t.text}</span>`;
        const prev = tokens[idx - 1];
        if (prev && prev.text === '.') return `<span class="fn">${t.text}</span>`;
      }
      return t.text;
    }).join('');
  }

  document.querySelectorAll('.code-raw').forEach(el => {
    el.innerHTML = highlightGo(el.textContent);
    el.classList.remove('code-raw');
  });
})();

// scroll tracking
(function() {
  const sections = Array.from(document.querySelectorAll('.concept[id]'));
  const sideLinks = document.querySelectorAll('.sidenav-link');
  const topLinks = document.querySelectorAll('.topnav-link');
  const topnav = document.querySelector('.topnav');
  const topnavH = topnav ? topnav.offsetHeight : 0;

  let jumping = false;

  function setActive(id) {
    sideLinks.forEach(a => a.classList.toggle('active', a.getAttribute('href') === '#' + id));
    topLinks.forEach(a => {
      const isActive = a.getAttribute('href') === '#' + id;
      a.classList.toggle('active', isActive);
      if (isActive && topnav) {
        topnav.scrollTo({ left: a.offsetLeft - topnav.offsetWidth / 2 + a.offsetWidth / 2, behavior: 'smooth' });
      }
    });
  }

  // intersection observer — suppressed during programmatic scrolls
  const observer = new IntersectionObserver(entries => {
    if (jumping) return;
    for (const entry of entries) {
      if (entry.isIntersecting) {
        setActive(entry.target.id);
      }
    }
  }, { rootMargin: '-20% 0px -70% 0px' });

  sections.forEach(s => observer.observe(s));

  // click: jump instantly, suppress observer until settled
  [...sideLinks, ...topLinks].forEach(link => {
    link.addEventListener('click', e => {
      e.preventDefault();
      const id = link.getAttribute('href').slice(1);
      const target = document.getElementById(id);
      if (target) {
        jumping = true;
        setActive(id);
        const y = target.getBoundingClientRect().top + window.scrollY - topnavH - 8;
        window.scrollTo({ top: y, behavior: 'instant' });
        history.replaceState(null, '', '#' + id);
        // re-enable observer after scroll settles
        setTimeout(() => { jumping = false; }, 100);
      }
    });
  });

  // activate first on load
  setActive(sections[0]?.id || '');
})();

// viewport scroll animation
(function() {
  const lines = [
    'package main',
    'import . "glyph"',
    '',
    'func main() {',
    '    app, _ := NewApp()',
    '    app.SetView(',
    '        VBox(',
    '            Text("hello"),',
    '        ),',
    '    )',
    '}'
  ];
  const height = 4;
  const maxScroll = lines.length - height;
  const bufferRows = document.querySelectorAll('#vp-buffer .buffer-row');
  const viewport = document.getElementById('vp-viewport');
  const vpRows = viewport.querySelectorAll('.buffer-row');
  const vpLabel = document.getElementById('vp-label');
  let scroll = 0;
  let dir = 1;
  let pause = 0;

  function apply(s) {
    bufferRows.forEach((row, i) => {
      row.classList.toggle('visible', i >= s && i < s + height);
    });
    vpLabel.textContent = 'Viewport (scroll=' + s + ', height=' + height + ')';
    vpRows.forEach((row, i) => {
      row.textContent = lines[s + i];
    });
  }

  function step() {
    if (pause > 0) { pause--; return; }
    scroll += dir;
    if (scroll >= maxScroll) { scroll = maxScroll; dir = -1; pause = 2; }
    if (scroll <= 0) { scroll = 0; dir = 1; pause = 2; }
    apply(scroll);
  }

  // only animate when visible
  const diagram = document.getElementById('vp-diagram');
  let timer = null;
  const obs = new IntersectionObserver(entries => {
    if (entries[0].isIntersecting) {
      if (!timer) timer = setInterval(step, 900);
    } else {
      clearInterval(timer);
      timer = null;
    }
  }, { threshold: 0.3 });
  obs.observe(diagram);
})();
</script>
</body>
</html>
