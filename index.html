<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>forme — Go TUI Framework</title>
<link rel="stylesheet" href="https://use.typekit.net/rgt4idh.css">
<style>
  @import url('https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&display=swap');

  @font-face {
    font-family: 'Berkeley Mono';
    src: local('Berkeley Mono'), local('BerkeleyMono-Regular');
    font-weight: 400;
  }
  @font-face {
    font-family: 'Berkeley Mono';
    src: local('Berkeley Mono'), local('BerkeleyMono-Bold');
    font-weight: 700;
  }

  /* ============================================================
     TOKENS
     ============================================================ */
  :root {
    /* backgrounds */
    --bg:       #f2f0ec;
    --bg2:      #e6e4de;
    --bg3:      #ffffff;
    --bg-dark:  #131311;
    --bg-dark2: #1a1a18;
    --bg-dark3: #0e0e0c;

    /* foregrounds */
    --fg0:  #131311;
    --fg:   #3a3a36;
    --fg2:  #6a6a64;
    --fg3:  #8a8880;
    --fg4:  #b0aba0;

    /* rules */
    --rule:    #d4d0c8;
    --rule-dk: #262624;

    /* accents */
    --accent:  #c47d3c;

    /* fonts */
    --mono:  'Berkeley Mono', 'DM Mono', monospace;
    --akz:   'akzidenz-grotesk-next-pro', sans-serif;
    --akz-c: 'akzidenz-grotesk-next-conden', sans-serif;
    --din-r: 'din-2014-rounded-variable', sans-serif;

    /* spacing */
    --s1: 8px;
    --s2: 16px;
    --s3: 24px;
    --s4: 32px;
    --s5: 48px;
    --s6: 64px;
    --s7: 80px;
    --s8: 120px;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  html { scroll-behavior: smooth; }

  body {
    background: var(--bg);
    color: var(--fg);
    font-family: var(--mono);
    font-size: 13px;
    line-height: 1.7;
    -webkit-font-smoothing: antialiased;
  }

  ::selection { background: var(--fg0); color: var(--bg); }

  /* ============================================================
     NAV
     ============================================================ */
  nav {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 100;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 var(--s5);
    transition: background 0.3s, border-color 0.3s;
    border-bottom: 1px solid transparent;
  }

  nav.scrolled {
    background: rgba(242, 240, 236, 0.95);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border-color: var(--rule);
  }

  nav.in-dark {
    background: rgba(19, 19, 17, 0.95);
    border-color: var(--rule-dk);
  }

  .nav-brand {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 400;
    font-size: 18px;
    color: var(--fg0);
    text-decoration: none;
    letter-spacing: -0.02em;
  }

  nav.in-dark .nav-brand { color: #e8e4d8; }

  .nav-links {
    display: flex;
    gap: var(--s3);
    list-style: none;
  }

  .nav-links a {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--fg3);
    text-decoration: none;
    transition: color 0.15s;
  }

  .nav-links a:hover { color: var(--fg0); }
  nav.in-dark .nav-links a { color: #555; }
  nav.in-dark .nav-links a:hover { color: #e8e4d8; }

  /* ============================================================
     LAYOUT
     ============================================================ */
  .zone-light { background: var(--bg); color: var(--fg); }
  .zone-dark  { background: var(--bg-dark); color: #c8c4b8; }
  .zone-inner { max-width: 1060px; margin: 0 auto; padding: 0 var(--s5); }
  .zone-rule  { height: 2px; background: var(--fg0); }

  /* ============================================================
     HERO
     ============================================================ */
  .hero {
    padding: 180px 0 var(--s7);
  }

  .hero-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.14em;
    color: var(--fg4);
    margin-bottom: var(--s3);
  }

  .hero-title {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 300;
    font-size: 96px;
    color: var(--fg0);
    line-height: 0.9;
    letter-spacing: -0.03em;
    margin-bottom: var(--s3);
  }

  .hero-desc {
    font-size: 14px;
    color: var(--fg2);
    line-height: 1.7;
    max-width: 480px;
    margin-bottom: var(--s5);
  }

  .hero-install {
    display: inline-flex;
    align-items: center;
    gap: var(--s2);
    background: var(--bg-dark);
    color: #c8c4b8;
    padding: 12px 20px;
    font-size: 13px;
    letter-spacing: 0.01em;
  }

  .hero-install .prompt { color: #555; user-select: none; }

  /* ============================================================
     SECTION HEADERS
     ============================================================ */
  .section-head {
    display: flex;
    align-items: flex-start;
    gap: var(--s4);
    padding: var(--s7) 0 var(--s4);
  }

  .section-num {
    font-family: var(--din-r);
    font-variation-settings: 'wght' 200;
    font-size: 84px;
    line-height: 0.82;
    letter-spacing: -0.04em;
    flex-shrink: 0;
    min-width: 110px;
  }

  .zone-light .section-num { color: var(--bg2); }
  .zone-dark .section-num  { color: #1e1e1c; }

  .section-meta { padding-top: 8px; }

  .section-label {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--fg4);
    margin-bottom: 4px;
  }

  .zone-dark .section-label { color: #444; }

  .section-title {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 34px;
    color: var(--fg0);
    letter-spacing: -0.02em;
    line-height: 1.1;
  }

  .zone-dark .section-title { color: #e8e4d8; }

  .section-desc {
    font-size: 12px;
    color: var(--fg3);
    line-height: 1.75;
    font-style: italic;
    max-width: 540px;
    margin: var(--s2) 0 var(--s5);
    border-left: 2px solid var(--rule);
    padding-left: 20px;
  }

  .zone-dark .section-desc { color: #666; border-color: #333; }

  /* ============================================================
     PATTERN LATTICE
     ============================================================ */
  .lattice {
    padding-bottom: var(--s7);
  }

  .lattice-scales {
    display: flex;
    flex-direction: column;
    gap: 2px;
    margin-bottom: var(--s5);
  }

  .lattice-scale {
    display: flex;
    align-items: stretch;
    gap: 2px;
  }

  .scale-label {
    width: 120px;
    flex-shrink: 0;
    padding: 12px 16px;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: var(--fg4);
    background: var(--bg3);
    display: flex;
    align-items: center;
  }

  .scale-nodes {
    display: flex;
    gap: 2px;
    flex: 1;
    flex-wrap: wrap;
  }

  .node {
    padding: 12px 16px;
    background: var(--bg3);
    font-size: 12px;
    color: var(--fg2);
    cursor: pointer;
    transition: all 0.15s;
    border: 1px solid transparent;
    flex: 1;
    min-width: 140px;
  }

  .node:hover {
    color: var(--fg0);
    border-color: var(--rule);
  }

  .node.active {
    color: var(--fg0);
    border-color: var(--fg0);
    background: var(--bg);
  }

  .node.connected {
    border-color: var(--accent);
    color: var(--fg0);
  }

  .node-id {
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--fg4);
    margin-bottom: 2px;
  }

  .node.active .node-id,
  .node.connected .node-id { color: var(--fg2); }

  /* pattern detail panel */
  .lattice-detail {
    background: var(--bg3);
    border: 1px solid var(--rule);
    padding: var(--s4);
    margin-top: var(--s3);
    display: none;
  }

  .lattice-detail.vis { display: block; }

  .detail-head {
    display: flex;
    align-items: baseline;
    gap: 12px;
    margin-bottom: var(--s2);
    padding-bottom: 12px;
    border-bottom: 1px solid var(--rule);
  }

  .detail-id { font-size: 10px; color: var(--fg4); }

  .detail-name {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 22px;
    color: var(--fg0);
  }

  .detail-confidence {
    display: flex;
    gap: 4px;
    margin-left: auto;
    align-items: center;
  }

  .conf-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
  }

  .conf-dot.on  { background: var(--fg0); }
  .conf-dot.off { border: 1px solid var(--fg4); }

  .detail-problem {
    font-size: 12px;
    color: var(--fg2);
    font-style: italic;
    line-height: 1.7;
    margin-bottom: 10px;
  }

  .detail-solution {
    font-size: 12px;
    color: var(--fg);
    line-height: 1.7;
    margin-bottom: var(--s2);
  }

  .therefore { color: var(--fg0); font-weight: 500; }

  .tags { display: flex; gap: 6px; flex-wrap: wrap; }

  .tag {
    font-size: 10px;
    padding: 4px 10px;
    border: 1px solid;
    cursor: pointer;
    transition: all 0.15s;
  }

  .tag:hover { opacity: 0.7; }
  .tag-up { border-color: var(--fg0); color: var(--fg0); }
  .tag-dn { border-color: var(--accent); color: var(--accent); }
  .tag-pr { border-color: var(--fg4); color: var(--fg2); }

  /* ============================================================
     CODE BLOCKS
     ============================================================ */
  .code {
    background: var(--bg-dark);
    padding: var(--s3);
    font-family: var(--mono);
    font-size: 12px;
    line-height: 1.8;
    margin: var(--s3) 0;
    overflow-x: auto;
    color: #c8c4b8;
  }

  .zone-dark .code {
    background: var(--bg-dark3);
    border: 1px solid var(--rule-dk);
  }

  .code .kw  { color: #9abf8a; }
  .code .fn  { color: #eeeee4; }
  .code .str { color: #c4a06a; }
  .code .cm  { color: #555; }
  .code .tp  { color: #7a9aba; }

  /* ============================================================
     INDEX ROWS
     ============================================================ */
  .index-row {
    display: grid;
    grid-template-columns: 56px 1fr auto;
    padding: 10px 0;
    border-bottom: 1px solid var(--rule);
    font-size: 11px;
    align-items: center;
    cursor: pointer;
    transition: color 0.1s;
    text-decoration: none;
    color: inherit;
  }

  .zone-dark .index-row { border-color: var(--rule-dk); }
  .index-row:hover { color: var(--fg0); }
  .zone-dark .index-row:hover { color: #f0ece0; }

  .index-id {
    color: var(--fg4);
    font-size: 10px;
  }

  .zone-dark .index-id { color: #444; }

  .index-name {
    text-transform: uppercase;
    letter-spacing: 0.04em;
  }

  .index-arrow {
    color: var(--fg4);
    transition: color 0.1s;
    padding-left: var(--s2);
  }

  .index-row:hover .index-arrow { color: var(--fg0); }
  .zone-dark .index-row:hover .index-arrow { color: #e8e4d8; }

  /* ============================================================
     API COMPONENT BLOCKS
     ============================================================ */
  .api-block {
    margin-bottom: var(--s6);
  }

  .api-name {
    font-family: var(--akz);
    font-weight: 700;
    font-size: 22px;
    letter-spacing: -0.01em;
    margin-bottom: 6px;
  }

  .zone-dark .api-name { color: #e8e4d8; }

  .api-desc {
    font-size: 12px;
    color: var(--fg3);
    line-height: 1.7;
    max-width: 560px;
    margin-bottom: var(--s3);
  }

  .zone-dark .api-desc { color: #777; }

  .api-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
    margin-bottom: var(--s3);
  }

  .api-table th {
    text-align: left;
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--fg4);
    padding: 8px 0;
    border-bottom: 2px solid var(--rule);
    font-weight: 400;
  }

  .zone-dark .api-table th { border-color: var(--rule-dk); color: #444; }

  .api-table td {
    padding: 8px 16px 8px 0;
    border-bottom: 1px solid var(--rule);
    vertical-align: top;
  }

  .zone-dark .api-table td { border-color: var(--rule-dk); }

  .api-table code {
    font-family: var(--mono);
    font-size: 12px;
  }

  .zone-dark .api-table td { color: #999; }
  .zone-dark .api-table code { color: #c8c4b8; }

  /* ============================================================
     FOOTER
     ============================================================ */
  footer {
    padding: var(--s5) 0;
    border-top: 1px solid var(--rule-dk);
    font-size: 11px;
    color: #444;
  }

  footer a {
    color: #666;
    text-decoration: none;
  }

  footer a:hover { color: #e8e4d8; }

  .footer-inner {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
</style>
</head>
<body>

<!-- ============================================================
     NAV
     ============================================================ -->
<nav id="nav">
  <a href="#" class="nav-brand">forme</a>
  <ul class="nav-links">
    <li><a href="#lattice">Patterns</a></li>
    <li><a href="#start">Start</a></li>
    <li><a href="#api">API</a></li>
    <li><a href="https://github.com/petegriffiths/forme">GitHub</a></li>
  </ul>
</nav>

<!-- ============================================================
     HERO
     ============================================================ -->
<div class="zone-light">
  <div class="zone-inner">
    <div class="hero">
      <div class="hero-label">Go TUI Framework</div>
      <div class="hero-title">forme</div>
      <div class="hero-desc">
        Compose terminal interfaces from simple components.
        Bind state through pointers. Handle input with vim-style patterns.
        No virtual DOM, no diffing — just functions and values.
      </div>
      <div class="hero-install">
        <span class="prompt">$</span>
        go get github.com/petegriffiths/forme@latest
      </div>
    </div>
  </div>
</div>

<!-- ============================================================
     PATTERN LATTICE
     ============================================================ -->
<div class="zone-light" id="lattice">
  <div class="zone-inner">
    <div class="lattice">
      <div class="section-head">
        <div class="section-num">01</div>
        <div class="section-meta">
          <div class="section-label">Patterns</div>
          <div class="section-title">Pattern Lattice</div>
        </div>
      </div>

      <div class="section-desc">
        Every component exists because of something above it and is
        implemented through something below it. Click a node to see
        its connections.
      </div>

      <div class="lattice-scales" id="lattice-grid">
        <!-- generated by JS -->
      </div>

      <div class="lattice-detail" id="lattice-detail">
        <div class="detail-head">
          <div class="detail-id" id="d-id"></div>
          <div class="detail-name" id="d-name"></div>
          <div class="detail-confidence" id="d-conf"></div>
        </div>
        <div class="detail-problem" id="d-problem"></div>
        <div class="detail-solution" id="d-solution"></div>
        <div class="tags" id="d-tags"></div>
      </div>
    </div>
  </div>
</div>

<div class="zone-rule"></div>

<!-- ============================================================
     GETTING STARTED
     ============================================================ -->
<div class="zone-dark" id="start">
  <div class="zone-inner">
    <div class="section-head">
      <div class="section-num">02</div>
      <div class="section-meta">
        <div class="section-label">Getting Started</div>
        <div class="section-title">First App</div>
      </div>
    </div>

    <div class="section-desc">
      A minimal forme application. Create an app, set a view, run.
    </div>

    <div class="code"><span class="kw">package</span> main

<span class="kw">import</span> <span class="str">"github.com/petegriffiths/forme"</span>

<span class="kw">func</span> <span class="fn">main</span>() {
    app, _ := forme.<span class="fn">NewApp</span>()

    app.<span class="fn">SetView</span>(
        forme.<span class="fn">VBox</span>(
            forme.<span class="fn">Text</span>(<span class="str">"Hello, forme"</span>),
            forme.<span class="fn">Text</span>(<span class="str">"Press q to quit"</span>),
        ),
    )

    app.<span class="fn">Handle</span>(<span class="str">"q"</span>, <span class="kw">func</span>() {
        app.<span class="fn">Quit</span>()
    })

    app.<span class="fn">Run</span>()
}</div>

    <div class="section-head">
      <div class="section-num">03</div>
      <div class="section-meta">
        <div class="section-label">Concepts</div>
        <div class="section-title">Pointer Semantics</div>
      </div>
    </div>

    <div class="section-desc">
      Pass pointers to values. The view tree is built once.
      At render time, pointers are dereferenced to get current state.
      No rebuilds, no diffing.
    </div>

    <div class="code">count := 0

app.<span class="fn">SetView</span>(
    forme.<span class="fn">VBox</span>(
        forme.<span class="fn">Text</span>(&count),  <span class="cm">// reads current value at render time</span>
        forme.<span class="fn">Text</span>(<span class="str">"Press + to increment"</span>),
    ),
)

app.<span class="fn">Handle</span>(<span class="str">"+"</span>, <span class="kw">func</span>() {
    count++
    app.<span class="fn">RequestRender</span>()
})</div>
  </div>
</div>

<!-- ============================================================
     API REFERENCE
     ============================================================ -->
<div class="zone-dark" id="api">
  <div class="zone-inner">
    <div class="section-head">
      <div class="section-num">04</div>
      <div class="section-meta">
        <div class="section-label">Reference</div>
        <div class="section-title">API</div>
      </div>
    </div>

    <div class="section-desc">
      Components, layout, input handling, and state management.
    </div>

    <!-- App -->
    <div class="api-block">
      <div class="api-name">App</div>
      <div class="api-desc">The root container. Creates the terminal session, manages views, routes input.</div>
      <div class="code">app, err := forme.<span class="fn">NewApp</span>()</div>
      <table class="api-table">
        <thead><tr><th>Method</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td><code>SetView(view)</code></td><td>Set the root view for single-view apps</td></tr>
          <tr><td><code>View(name, view)</code></td><td>Register a named view for multi-view routing</td></tr>
          <tr><td><code>Handle(pattern, fn)</code></td><td>Register a key handler</td></tr>
          <tr><td><code>Go(name)</code></td><td>Navigate to a named view</td></tr>
          <tr><td><code>Run()</code></td><td>Start the application</td></tr>
          <tr><td><code>Quit()</code></td><td>Exit cleanly</td></tr>
          <tr><td><code>RequestRender()</code></td><td>Schedule a re-render on next frame</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Layout -->
    <div class="api-block">
      <div class="api-name">Layout</div>
      <div class="api-desc">Compose views spatially. Flex-like model — grow, shrink, fixed, percentage.</div>
      <table class="api-table">
        <thead><tr><th>Function</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td><code>VBox(children...)</code></td><td>Vertical stack</td></tr>
          <tr><td><code>HBox(children...)</code></td><td>Horizontal stack</td></tr>
          <tr><td><code>Grow(child)</code></td><td>Fill remaining space</td></tr>
          <tr><td><code>WidthPct(n, child)</code></td><td>Percentage width</td></tr>
          <tr><td><code>Gap(n)</code></td><td>Fixed spacing</td></tr>
          <tr><td><code>Arrange(children...)</code></td><td>Manual positioning</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Components index -->
    <div class="api-block">
      <div class="api-name">Components</div>
      <div class="api-desc">The building blocks. Each is a function that returns a node.</div>
      <div style="margin-top: var(--s2);">
        <div class="index-row"><div class="index-id">text</div><div class="index-name">Text</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">input</div><div class="index-name">Input</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">list</div><div class="index-name">List / FilterList</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">tabs</div><div class="index-name">Tabs</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">jump</div><div class="index-name">Jump</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">layer</div><div class="index-name">Layer / LayerView</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">overlay</div><div class="index-name">Overlay</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">progress</div><div class="index-name">Progress / Spinner</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">spark</div><div class="index-name">Sparkline</div><div class="index-arrow">↗</div></div>
        <div class="index-row"><div class="index-id">widget</div><div class="index-name">Widget (Custom)</div><div class="index-arrow">↗</div></div>
      </div>
    </div>

    <!-- Conditionals -->
    <div class="api-block">
      <div class="api-name">Conditionals</div>
      <div class="api-desc">Show and hide nodes based on pointer values. Evaluated at render time.</div>
      <table class="api-table">
        <thead><tr><th>Function</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td><code>If(&bool).Then(node)</code></td><td>Conditional render</td></tr>
          <tr><td><code>If(&bool).Then(a).Else(b)</code></td><td>Conditional with fallback</td></tr>
          <tr><td><code>Switch(&val).Case(v, node)</code></td><td>Multi-value conditional</td></tr>
          <tr><td><code>ForEach(&slice, fn)</code></td><td>Dynamic list from pointer to slice</td></tr>
        </tbody>
      </table>
    </div>

    <!-- Style -->
    <div class="api-block">
      <div class="api-name">Style</div>
      <div class="api-desc">Visual properties. Applied directly or cascaded from parent.</div>
      <div class="code">s := forme.<span class="fn">Style</span>{
    <span class="tp">Bold</span>:       <span class="kw">true</span>,
    <span class="tp">FG</span>:         forme.<span class="fn">RGB</span>(200, 180, 160),
    <span class="tp">Border</span>:     forme.<span class="fn">BorderRounded</span>,
    <span class="tp">PaddingX</span>:   2,
    <span class="tp">PaddingY</span>:   1,
}

forme.<span class="fn">CascadeStyle</span>(&s, child)</div>
    </div>
  </div>
</div>

<!-- ============================================================
     FOOTER
     ============================================================ -->
<div class="zone-dark">
  <div class="zone-inner">
    <footer>
      <div class="footer-inner">
        <span>forme — built by <a href="#">Pete Griffiths</a></span>
        <span><a href="https://github.com/petegriffiths/forme">source</a></span>
      </div>
    </footer>
  </div>
</div>

<!-- ============================================================
     JAVASCRIPT
     ============================================================ -->
<script>
// pattern data
const patterns = [
  // philosophy
  { id: 'P01', name: 'Compile Once, Render Forever', scale: 'philosophy', conf: 2,
    problem: 'Rebuilding the UI tree every frame causes allocation pressure, reflection overhead, and unpredictable latency in terminal rendering.',
    solution: 'Build() compiles the declarative view tree into a flat Op array once at SetView() time. All reflection happens at compile time. Execute() is pure pointer arithmetic with zero allocation in steady state.',
    up: [], down: ['S01', 'S02', 'S03', 'S05', 'S06'], peer: ['P02'] },

  { id: 'P02', name: 'Pointer Semantics', scale: 'philosophy', conf: 2,
    problem: 'Reactive UI frameworks require subscription systems, diffing algorithms, or signals to detect state changes — adding complexity and indirection.',
    solution: 'State is updated by mutating values behind pointers (*string, *int, *bool, *[]T). The compiled template dereferences these pointers every frame. No subscriptions, no diffing of state — just pointer reads.',
    up: [], down: ['S02', 'S03', 'S04'], peer: ['P01'] },

  { id: 'P03', name: 'Declarative Composition', scale: 'philosophy', conf: 2,
    problem: 'Imperative UI code tangles layout, styling, event handling, and state management into unreadable spaghetti.',
    solution: 'Views are declared as composable trees using function-type-with-methods constructors (VBox.Fill(Red).Gap(2)(children...)). Components declare their key bindings as data via the bindable interface, wired automatically at compile time.',
    up: [], down: ['S01', 'S04', 'S06', 'C01', 'C02', 'C03', 'C04', 'C05', 'C06', 'C07'], peer: [] },

  { id: 'P04', name: 'Zero-Cost Terminal Abstraction', scale: 'philosophy', conf: 2,
    problem: 'Terminal programs waste bandwidth and cause flicker by rewriting unchanged content, and pay syscall overhead on every escape sequence.',
    solution: 'Double-buffered diff rendering compares back buffer against front buffer cell-by-cell, emitting only changes. All output is batched into a single write() syscall per frame.',
    up: [], down: ['S05'], peer: [] },

  // systems
  { id: 'S01', name: 'Template Compiler', scale: 'systems', conf: 2,
    problem: 'A declarative view tree made of Go structs and interfaces cannot be executed efficiently without transformation — runtime type switches on every frame would be prohibitive.',
    solution: 'The compile() method performs a ~40-type switch once, producing a flat []Op array with a parallel []Geom array. Control flow (If/ForEach/Switch) compiles branches as sub-Templates. ForEach uses unsafe pointer offsets computed from a prototype element at compile time.',
    up: ['P01', 'P03'], down: ['C01', 'C02', 'C03', 'C04', 'C05', 'C06', 'C07'], peer: ['S02', 'S03', 'S04', 'S05', 'S06'] },

  { id: 'S02', name: 'Three-Way Value Resolution', scale: 'systems', conf: 2,
    problem: 'Values in a compiled template need to support static content, dynamic pointers, AND per-element rebinding inside ForEach — three distinct resolution strategies from one data structure.',
    solution: 'Every value-carrying Op exists in three variants: Static (OpText), Ptr (OpTextPtr — *string dereferenced each frame), and Off (OpTextOff — uintptr offset added to ForEach element base via unsafe.Add). Conditions use evaluateWithBase() for the same offset trick.',
    up: ['P01', 'P02'], down: [], peer: ['S01', 'S03'] },

  { id: 'S03', name: 'Layout Engine', scale: 'systems', conf: 2,
    problem: 'Terminal UIs need CSS-like flex layout but cannot afford the complexity or allocation cost of a full layout engine.',
    solution: 'A four-phase pipeline: top-down width distribution with two-pass HBox flex, bottom-up height computation, top-down flex grow distribution, top-down render. All phases share scratch buffers for zero allocation.',
    up: ['P01', 'P02'], down: ['C01', 'D03'], peer: ['S01', 'S02', 'S05'] },

  { id: 'S04', name: 'Event System', scale: 'systems', conf: 2,
    problem: 'Terminal UIs need modal key handling, vim-style multi-key sequences, text input routing, and focus management — wiring this manually per component is error-prone.',
    solution: 'riffkey provides a Router stack with push/pop for modal input. Components declare bindings as data (bindable interface), auto-wired at compile time. FocusManager coordinates Tab/Shift-Tab cycling and routes unmatched keys to the focused component.',
    up: ['P02', 'P03'], down: ['C02', 'C05', 'C06', 'D05'], peer: ['S01', 'S06'] },

  { id: 'S05', name: 'Render Pipeline', scale: 'systems', conf: 2,
    problem: 'Getting cells from a compiled template to the terminal requires careful orchestration of buffering, diffing, cursor management, and output batching.',
    solution: 'App.render() orchestrates: Execute() into BufferPool → CopyFrom() to Screen back buffer → Flush() diffs against front buffer → FlushBuffer() writes everything in one syscall → BufferPool.Swap() clears via partial ClearDirty().',
    up: ['P01', 'P04'], down: ['D01', 'D02', 'D04'], peer: ['S01', 'S03'] },

  { id: 'S06', name: 'View Routing', scale: 'systems', conf: 1,
    problem: 'Applications with multiple screens need view switching, view-specific key bindings, and modal overlays without recompiling templates.',
    solution: 'Named views each get their own compiled Template and riffkey Router. Go() swaps the active template and router. PushView()/PopView() manage a view stack for modal overlays.',
    up: ['P01', 'P03'], down: [], peer: ['S01', 'S04'] },

  // components
  { id: 'C01', name: 'Containers & Layout Primitives', scale: 'components', conf: 2,
    problem: 'Building complex layouts requires composable containers with flex, borders, margins, gaps, style cascade, and content sizing — plus an escape hatch for custom layouts.',
    solution: 'VBox/HBox with the function-type-with-methods pattern, supporting Fill, CascadeStyle, Gap, Border, Margin, Grow, FitContent, WidthPct. Arrange() provides custom LayoutFunc. Overlay for floating content.',
    up: ['P03', 'S01', 'S03'], down: ['D03', 'D04'], peer: ['C02', 'C04'] },

  { id: 'C02', name: 'Lists & Selection', scale: 'components', conf: 2,
    problem: 'Navigable lists with selection, scrolling, custom rendering, and type-safe item access are a core building block that every TUI needs.',
    solution: 'Generic ListC[T] backed by *[]T with windowed scrolling, custom Render func, selection marker, and declarative BindNav/BindVimNav. CheckListC[T] extends with per-item checkboxes and struct tag inference.',
    up: ['P03', 'S01', 'S04'], down: [], peer: ['C01', 'C05', 'C06'] },

  { id: 'C03', name: 'Data Display', scale: 'components', conf: 2,
    problem: 'Displaying structured data (tables, sparklines, progress bars, leaders, trees) requires specialised rendering with alignment, formatting, and dynamic binding.',
    solution: 'AutoTable reflects struct fields into columns with functional ColumnOption presets (Number, Currency, Percent, Bytes, StyleThreshold). Sparkline, Progress with sub-character precision, Leader, and TreeView round out the toolkit.',
    up: ['P03', 'S01'], down: ['D03', 'D04'], peer: ['C04'] },

  { id: 'C04', name: 'Text & Rich Text', scale: 'components', conf: 2,
    problem: 'Terminal text needs per-character styling, text transforms, multi-span inline styling, and alignment — all within the pointer-binding reactive model.',
    solution: 'TextC with value-receiver chaining (.Bold().FG(Red)), Span-based RichTextNode for mixed inline styles, and helper functions (Rich, Bold, Dim, FG, BG). Style inheritance cascades through CascadeStyle on containers.',
    up: ['P03', 'S01'], down: ['D04', 'D05'], peer: ['C01', 'C03'] },

  { id: 'C05', name: 'Filtering & Search', scale: 'components', conf: 2,
    problem: 'Interactive lists and logs need real-time fzf-style filtering that maintains index mapping back to the source data for correct item selection.',
    solution: 'Filter[T] provides generic fzf filtering with scored ranking and index mapping. FilterListC[T] composes Input + Filter + List into a single node. FilterLogC extends LogC with per-line filtering. Full fzf query syntax: fuzzy, exact, prefix, suffix, negation, AND/OR.',
    up: ['P03', 'S01', 'S04'], down: [], peer: ['C02', 'C06', 'C07'] },

  { id: 'C06', name: 'Forms & Input', scale: 'components', conf: 2,
    problem: 'Text input, checkboxes, radio buttons, and multi-field forms need focus management, keystroke routing, and state binding — composing many subsystems correctly.',
    solution: 'InputC wraps InputState with placeholder, mask, and FocusManager integration. Checkbox/Radio with pointer-bound state and declarative BindToggle/BindNav. FocusManager coordinates Tab/Shift-Tab cycling across focusable components.',
    up: ['P03', 'S01', 'S04'], down: [], peer: ['C02', 'C05'] },

  { id: 'C07', name: 'Layers & Scrolling', scale: 'components', conf: 1,
    problem: 'Content taller than the viewport needs pre-rendered off-screen buffers with scroll management, lazy re-rendering, and cursor coordinate translation.',
    solution: 'Layer provides a pre-rendered Buffer with scroll API, lazy Render callback on viewport width changes, and ScreenCursor() for coordinate translation. LogC extends Layer with io.Reader background ingestion and auto-scroll following.',
    up: ['P03', 'S01'], down: ['D01'], peer: ['C05'] },

  // details
  { id: 'D01', name: 'Double Buffer & Cell Grid', scale: 'details', conf: 2,
    problem: 'Rendering needs a drawable surface with dirty tracking, fast clearing, and double buffering to avoid tearing or redundant redraws.',
    solution: 'Buffer is a flat []Cell array with per-row dirty flags and dirtyMaxY partial-clear optimization. BufferPool alternates two buffers via atomic swap. Region provides zero-copy sub-buffer views.',
    up: ['S05', 'C07'], down: [], peer: ['D02'] },

  { id: 'D02', name: 'Terminal Protocol', scale: 'details', conf: 2,
    problem: 'Communicating with the terminal requires raw mode, ANSI escape sequences, signal handling, cursor management, and platform-specific ioctls.',
    solution: 'Screen manages termios, raw mode, alternate buffer, and SIGWINCH. Flush() emits minimal ANSI with allocation-free integer formatting. CJK double-width handled with placeholder cells and ASCII fast path.',
    up: ['S05'], down: [], peer: ['D01'] },

  { id: 'D03', name: 'Borders & Box Drawing', scale: 'details', conf: 2,
    problem: 'Nested containers with borders produce junction characters that must merge correctly without explicit coordination between components.',
    solution: 'Automatic border merging via bitmask OR of edge flags. borderEdgesArray maps box-drawing runes to 4-bit edge flags, edgesToBorderArray maps merged flags back to junction characters. Three built-in styles: Single, Rounded, Double.',
    up: ['S03', 'C01', 'C03'], down: [], peer: ['D04'] },

  { id: 'D04', name: 'Style & Colour System', scale: 'details', conf: 2,
    problem: 'Terminal styling requires managing colours across four modes, text attributes as composable bitmasks, text transforms, alignment, and style inheritance.',
    solution: 'Style struct combines FG/BG/Fill Color, Attribute bitmask, TextTransform, and Align. Color supports Default/16/256/RGB. CascadeStyle *Style on containers enables dynamic theme switching via pointer. effectiveStyle() merges inherited attributes and colours.',
    up: ['S05', 'C01', 'C03', 'C04'], down: [], peer: ['D03', 'D05'] },

  { id: 'D05', name: 'Jump Labels', scale: 'details', conf: 2,
    problem: 'Keyboard-driven UIs need a way to target arbitrary screen locations without sequential navigation — the terminal equivalent of clicking.',
    solution: 'JumpMode collects targets during a render pass, assigns home-row-first labels, pushes a temporary riffkey Router handling multi-char input accumulation with partial matching. Jump wraps any component as a target.',
    up: ['C04', 'S04'], down: [], peer: ['D04'] },
];

const scaleOrder = ['philosophy', 'systems', 'components', 'details'];
const scaleLabels = { philosophy: 'Philosophy', systems: 'Systems', components: 'Components', details: 'Details' };

// build lattice grid
const grid = document.getElementById('lattice-grid');

scaleOrder.forEach(scale => {
  const row = document.createElement('div');
  row.className = 'lattice-scale';

  const label = document.createElement('div');
  label.className = 'scale-label';
  label.textContent = scaleLabels[scale];
  row.appendChild(label);

  const nodes = document.createElement('div');
  nodes.className = 'scale-nodes';

  patterns.filter(p => p.scale === scale).forEach(p => {
    const node = document.createElement('div');
    node.className = 'node';
    node.dataset.id = p.id;
    node.innerHTML = `<div class="node-id">${p.id}</div>${p.name}`;
    node.addEventListener('click', () => selectPattern(p.id));
    nodes.appendChild(node);
  });

  row.appendChild(nodes);
  grid.appendChild(row);
});

function selectPattern(id) {
  const p = patterns.find(x => x.id === id);
  if (!p) return;

  // clear all states
  document.querySelectorAll('.node').forEach(n => {
    n.classList.remove('active', 'connected');
  });

  // highlight active
  const active = document.querySelector(`.node[data-id="${id}"]`);
  if (active) active.classList.add('active');

  // highlight connected
  const allConnected = [...p.up, ...p.down, ...p.peer];
  allConnected.forEach(cid => {
    const el = document.querySelector(`.node[data-id="${cid}"]`);
    if (el) el.classList.add('connected');
  });

  // fill detail
  document.getElementById('d-id').textContent = p.id;
  document.getElementById('d-name').textContent = p.name;

  const conf = document.getElementById('d-conf');
  conf.innerHTML = '';
  for (let i = 0; i < 2; i++) {
    const dot = document.createElement('div');
    dot.className = 'conf-dot ' + (i < p.conf ? 'on' : 'off');
    conf.appendChild(dot);
  }

  document.getElementById('d-problem').textContent = p.problem;
  document.getElementById('d-solution').innerHTML = `<span class="therefore">Therefore:</span> ${p.solution}`;

  const tags = document.getElementById('d-tags');
  tags.innerHTML = '';

  p.up.forEach(cid => {
    const t = document.createElement('span');
    t.className = 'tag tag-up';
    const cp = patterns.find(x => x.id === cid);
    t.textContent = `↑ ${cp ? cp.name : cid}`;
    t.addEventListener('click', (e) => { e.stopPropagation(); selectPattern(cid); });
    tags.appendChild(t);
  });

  p.peer.forEach(cid => {
    const t = document.createElement('span');
    t.className = 'tag tag-pr';
    const cp = patterns.find(x => x.id === cid);
    t.textContent = `↔ ${cp ? cp.name : cid}`;
    t.addEventListener('click', (e) => { e.stopPropagation(); selectPattern(cid); });
    tags.appendChild(t);
  });

  p.down.forEach(cid => {
    const t = document.createElement('span');
    t.className = 'tag tag-dn';
    const cp = patterns.find(x => x.id === cid);
    t.textContent = `↓ ${cp ? cp.name : cid}`;
    t.addEventListener('click', (e) => { e.stopPropagation(); selectPattern(cid); });
    tags.appendChild(t);
  });

  document.getElementById('lattice-detail').classList.add('vis');
}

// nav scroll behavior
const navEl = document.getElementById('nav');
const darkZone = document.getElementById('start');

function updateNav() {
  const scrollY = window.scrollY;
  const darkTop = darkZone.offsetTop - 48;

  if (scrollY > 20) {
    navEl.classList.add('scrolled');
  } else {
    navEl.classList.remove('scrolled');
  }

  if (scrollY >= darkTop) {
    navEl.classList.add('in-dark');
  } else {
    navEl.classList.remove('in-dark');
  }
}

window.addEventListener('scroll', updateNav, { passive: true });
updateNav();
</script>
</body>
</html>
