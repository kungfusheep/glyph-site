{
  "name": "glyph",
  "import_path": "github.com/kungfusheep/glyph",
  "doc": "Package glyph provides a high-performance terminal UI framework.\n",
  "types": [
    {
      "name": "Align",
      "doc": "Align specifies text alignment within a cell.\n",
      "decl": "type Align uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "AlignLeft",
            "AlignRight",
            "AlignCenter"
          ],
          "decl": "const (\n\tAlignLeft Align = iota\n\tAlignRight\n\tAlignCenter\n)"
        }
      ],
      "examples": [
        {
          "doc": "Text alignment.\nAlign is set via the Style struct — AlignLeft, AlignCenter, or AlignRight within a fixed width.\n",
          "code": "VBox(\n\tText(\"left-aligned\"),\n\tText(\"centered\").Style(Style{Align: AlignCenter}).Width(40),\n\tText(\"right-aligned\").Style(Style{Align: AlignRight}).Width(40),\n)"
        }
      ]
    },
    {
      "name": "App",
      "doc": "App is a TUI application with integrated input handling via riffkey.\n",
      "decl": "type App struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewApp",
          "doc": "NewApp creates a new TUI application (fullscreen, alternate buffer).\n",
          "signature": "func NewApp() (*App, error)",
          "examples": [
            {
              "doc": "Full-screen app.\nSetView compiles the tree once, Handle binds keys, Run blocks until Stop is called.\n",
              "code": "app, _ := NewApp()\n\ncounter := 0\napp.SetView(\n\tVBox(\n\t\tText(\u0026counter),\n\t\tText(\"press q to quit\"),\n\t),\n)\napp.Handle(\"q\", func() { app.Stop() })\napp.Run()"
            }
          ]
        },
        {
          "name": "NewInlineApp",
          "doc": "NewInlineApp creates a new inline TUI application.\nInline apps render at the current cursor position without taking over the screen.\nUse this for progress bars, selection menus, spinners, etc.\n",
          "signature": "func NewInlineApp() (*App, error)",
          "examples": [
            {
              "doc": "Inline app.\nRenders within the terminal flow instead of taking over the screen. Height sets the visible rows.\n",
              "code": "app, _ := NewInlineApp()\n\nstatus := \"loading...\"\napp.SetView(Text(\u0026status))\napp.Height(3).ClearOnExit(true)\napp.Run()"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "AddJumpTarget",
          "doc": "AddJumpTarget registers a jump target during rendering.\nCalled by Jump components when jump mode is active.\n",
          "signature": "func (a *App) AddJumpTarget(x, y int16, onSelect func(), style Style)",
          "recv": "*App"
        },
        {
          "name": "Back",
          "doc": "Back returns to the previous view.\nCurrently an alias for Pop() - may add history later.\n",
          "signature": "func (a *App) Back()",
          "recv": "*App"
        },
        {
          "name": "BindField",
          "doc": "BindField routes unmatched keys to a text input field.\n",
          "signature": "func (a *App) BindField(f *InputState) *App",
          "recv": "*App"
        },
        {
          "name": "ClearOnExit",
          "doc": "ClearOnExit sets whether the inline app should clear its content on exit.\nIf true, the rendered content disappears when the app stops.\nIf false (default), the content remains visible and cursor moves below it.\n",
          "signature": "func (a *App) ClearOnExit(clear bool) *App",
          "recv": "*App"
        },
        {
          "name": "Cursor",
          "doc": "Cursor returns the current cursor state.\n",
          "signature": "func (a *App) Cursor() Cursor",
          "recv": "*App"
        },
        {
          "name": "EnterJumpMode",
          "doc": "EnterJumpMode activates jump label mode.\nA render is triggered to collect jump targets, then a temporary router\nis pushed to handle label input.\n",
          "signature": "func (a *App) EnterJumpMode()",
          "recv": "*App"
        },
        {
          "name": "ExitJumpMode",
          "doc": "ExitJumpMode deactivates jump label mode.\n",
          "signature": "func (a *App) ExitJumpMode()",
          "recv": "*App"
        },
        {
          "name": "Go",
          "doc": "Go switches to a different view.\nSwaps the template and input handlers.\n",
          "signature": "func (a *App) Go(name string)",
          "recv": "*App"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a key binding with a vim-style pattern.\nExamples: \"j\", \"gg\", \"\u003cC-c\u003e\", \"\u003cC-w\u003ej\", \"\u003cUp\u003e\"\nAccepts func(riffkey.Match), func(any), or func() for convenience.\nAutomatically requests a re-render after the handler runs.\n",
          "signature": "func (a *App) Handle(pattern string, handler any) *App",
          "recv": "*App"
        },
        {
          "name": "HandleNamed",
          "doc": "HandleNamed registers a named key binding (for rebinding support).\nAutomatically requests a re-render after the handler runs.\n",
          "signature": "func (a *App) HandleNamed(name, pattern string, handler func(riffkey.Match)) *App",
          "recv": "*App"
        },
        {
          "name": "Height",
          "doc": "Height sets the height for inline apps.\nThis determines how many lines the inline view will use.\nIf not set, defaults to 1.\n",
          "signature": "func (a *App) Height(h int16) *App",
          "recv": "*App"
        },
        {
          "name": "HideCursor",
          "doc": "HideCursor hides the cursor.\n",
          "signature": "func (a *App) HideCursor()",
          "recv": "*App"
        },
        {
          "name": "Input",
          "doc": "Input returns the riffkey input for modal handling (push/pop).\n",
          "signature": "func (a *App) Input() *riffkey.Input",
          "recv": "*App"
        },
        {
          "name": "IsInline",
          "doc": "IsInline returns true if this is an inline app.\n",
          "signature": "func (a *App) IsInline() bool",
          "recv": "*App"
        },
        {
          "name": "JumpKey",
          "doc": "JumpKey registers a key pattern to trigger jump mode.\nThis is a convenience method that calls EnterJumpMode when the key is pressed.\n",
          "signature": "func (a *App) JumpKey(pattern string) *App",
          "recv": "*App"
        },
        {
          "name": "JumpMode",
          "doc": "JumpMode returns the jump mode state for use during rendering.\n",
          "signature": "func (a *App) JumpMode() *JumpMode",
          "recv": "*App"
        },
        {
          "name": "JumpModeActive",
          "doc": "JumpModeActive returns true if jump mode is currently active.\n",
          "signature": "func (a *App) JumpModeActive() bool",
          "recv": "*App"
        },
        {
          "name": "JumpStyle",
          "doc": "JumpStyle returns the current jump style.\n",
          "signature": "func (a *App) JumpStyle() JumpStyle",
          "recv": "*App"
        },
        {
          "name": "OnAfterRender",
          "doc": "OnAfterRender sets a callback to be called after each render completes.\nUse this to update cursor position after layout is known.\n",
          "signature": "func (a *App) OnAfterRender(fn func())",
          "recv": "*App"
        },
        {
          "name": "OnBeforeRender",
          "doc": "OnBeforeRender sets a callback to be called before each render.\nUse this to sync state (e.g., filter updates) before layout runs.\n",
          "signature": "func (a *App) OnBeforeRender(fn func())",
          "recv": "*App"
        },
        {
          "name": "OnResize",
          "doc": "OnResize sets a callback to be called when the terminal is resized.\nThe callback receives the new width and height.\nUse this to update viewport dimensions, reinitialize layers, etc.\n",
          "signature": "func (a *App) OnResize(fn func(width, height int))",
          "recv": "*App"
        },
        {
          "name": "Pop",
          "doc": "Pop pops the current router from the input stack.\n",
          "signature": "func (a *App) Pop()",
          "recv": "*App"
        },
        {
          "name": "PopView",
          "doc": "PopView removes the top modal overlay.\nReturns to the previous view in the stack.\n",
          "signature": "func (a *App) PopView()",
          "recv": "*App"
        },
        {
          "name": "Push",
          "doc": "Push pushes a new router onto the input stack (for modal input).\n",
          "signature": "func (a *App) Push(r *riffkey.Router)",
          "recv": "*App"
        },
        {
          "name": "PushView",
          "doc": "PushView pushes a view as a modal overlay.\nThe modal's handlers take precedence until PopView() is called.\nThe pushed view becomes the active rendered view until popped.\n",
          "signature": "func (a *App) PushView(name string)",
          "recv": "*App"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (a *App) Ref(f func(*App)) *App",
          "recv": "*App"
        },
        {
          "name": "RenderNow",
          "doc": "RenderNow performs a render immediately without channel coordination.\nUse this from dedicated update goroutines to avoid scheduler overhead.\nThe render is mutex-protected so it's safe to call concurrently.\n",
          "signature": "func (a *App) RenderNow()",
          "recv": "*App"
        },
        {
          "name": "RequestRender",
          "doc": "RequestRender marks that a render is needed.\nSafe to call from any goroutine.\n",
          "signature": "func (a *App) RequestRender()",
          "recv": "*App"
        },
        {
          "name": "Router",
          "doc": "Router returns the riffkey router for advanced configuration.\n",
          "signature": "func (a *App) Router() *riffkey.Router",
          "recv": "*App"
        },
        {
          "name": "Run",
          "doc": "Run starts the application. Blocks until Stop is called.\nFor multi-view apps, use RunFrom(startView) instead.\n",
          "signature": "func (a *App) Run() error",
          "recv": "*App"
        },
        {
          "name": "RunFrom",
          "doc": "RunFrom starts the application on the specified view.\nUse this for multi-view apps.\n",
          "signature": "func (a *App) RunFrom(startView string) error",
          "recv": "*App"
        },
        {
          "name": "RunNonInteractive",
          "doc": "RunNonInteractive runs an inline app without an input loop.\nUse this for progress bars, spinners, etc. that don't need keyboard input.\nCall Stop() when done to clean up and exit.\n",
          "signature": "func (a *App) RunNonInteractive() error",
          "recv": "*App"
        },
        {
          "name": "Screen",
          "doc": "Screen returns the screen.\n",
          "signature": "func (a *App) Screen() *Screen",
          "recv": "*App"
        },
        {
          "name": "SetCursor",
          "doc": "SetCursor sets the cursor position (0-indexed screen coordinates).\nThe cursor will be positioned here after each render.\n",
          "signature": "func (a *App) SetCursor(x, y int)",
          "recv": "*App"
        },
        {
          "name": "SetCursorColor",
          "doc": "SetCursorColor sets the cursor color using OSC 12 escape sequence.\nThis changes the actual cursor color in supporting terminals.\n",
          "signature": "func (a *App) SetCursorColor(c Color)",
          "recv": "*App"
        },
        {
          "name": "SetCursorStyle",
          "doc": "SetCursorStyle sets the cursor visual style.\n",
          "signature": "func (a *App) SetCursorStyle(style CursorShape)",
          "recv": "*App"
        },
        {
          "name": "SetJumpStyle",
          "doc": "SetJumpStyle sets the global style for jump labels.\n",
          "signature": "func (a *App) SetJumpStyle(style JumpStyle) *App",
          "recv": "*App"
        },
        {
          "name": "SetView",
          "doc": "SetView sets a declarative view for fast rendering.\nPointers in the view are captured at compile time - just mutate your state.\n\nExample:\n\n\tstate := \u0026MyState{Title: \"Hello\", Progress: 50}\n\tapp.SetView(\n\t    Col{Children: []any{\n\t        Text{Content: \u0026state.Title},\n\t        Progress{Value: \u0026state.Progress},\n\t    }},\n\t)\n",
          "signature": "func (a *App) SetView(view any) *App",
          "recv": "*App"
        },
        {
          "name": "SetViewLimit",
          "doc": "SetViewLimit sets the maximum number of times SetView can be called.\nPanics if exceeded. Use this to catch anti-patterns where SetView is called\nrepeatedly instead of using reactive updates via pointers.\n\nExample:\n\n\tapp.SetViewLimit(1) // Panic if SetView called more than once\n\tapp.SetView(myView) // OK\n\tapp.SetView(other)  // PANIC: SetView called 2 times, limit is 1\n\nSet to 0 (default) for unlimited calls.\n",
          "signature": "func (a *App) SetViewLimit(n int) *App",
          "recv": "*App"
        },
        {
          "name": "ShowCursor",
          "doc": "ShowCursor makes the cursor visible.\n",
          "signature": "func (a *App) ShowCursor()",
          "recv": "*App"
        },
        {
          "name": "Size",
          "doc": "Size returns the current screen size.\n",
          "signature": "func (a *App) Size() Size",
          "recv": "*App"
        },
        {
          "name": "Stop",
          "doc": "Stop signals the application to stop.\n",
          "signature": "func (a *App) Stop()",
          "recv": "*App"
        },
        {
          "name": "Template",
          "doc": "Template returns the current template for debugging.\nUse with Template().DebugDump(\"\") to inspect the op tree.\n",
          "signature": "func (a *App) Template() *Template",
          "recv": "*App"
        },
        {
          "name": "UnbindField",
          "doc": "UnbindField clears the text input field binding.\n",
          "signature": "func (a *App) UnbindField() *App",
          "recv": "*App"
        },
        {
          "name": "UpdateView",
          "doc": "UpdateView recompiles a view with a new view definition.\nUse this when the view's structure changes and needs re-compilation.\n",
          "signature": "func (a *App) UpdateView(name string, view any)",
          "recv": "*App"
        },
        {
          "name": "View",
          "doc": "View registers a named view for multi-view routing.\nReturns a builder for chaining Handle() calls.\n\nExample:\n\n\tapp.View(\"home\", homeView).\n\t    Handle(\"j\", moveDown).\n\t    Handle(\"s\", func(_ riffkey.Match) { app.Go(\"settings\") })\n",
          "signature": "func (a *App) View(name string, view any) *ViewBuilder",
          "recv": "*App"
        },
        {
          "name": "ViewRouter",
          "doc": "ViewRouter returns the router for a named view, if it exists.\nUseful for advanced configuration like HandleUnmatched.\n",
          "signature": "func (a *App) ViewRouter(name string) (*riffkey.Router, bool)",
          "recv": "*App"
        }
      ],
      "examples": [
        {
          "name": "goroutine",
          "doc": "Goroutine updates.\nMutate the value behind the pointer from any goroutine, then call RequestRender to trigger a redraw.\n",
          "code": "app, _ := NewApp()\n\nstatus := \"waiting...\"\napp.SetView(Text(\u0026status))\napp.Handle(\"q\", func() { app.Stop() })\n\ntime.AfterFunc(2*time.Second, func() {\n\tstatus = \"done!\"\n\tapp.RequestRender()\n})\n\napp.Run()"
        },
        {
          "name": "multiView",
          "doc": "Multi-view routing.\nNamed views with per-view key bindings. Go switches between views; each view is compiled independently.\n",
          "code": "app, _ := NewApp()\n\napp.View(\"home\", VBox(\n\tText(\"Welcome\"),\n\tText(\"press n for next\"),\n)).Handle(\"n\", func() { app.Go(\"detail\") })\n\napp.View(\"detail\", VBox(\n\tText(\"Detail view\"),\n\tText(\"press b for back\"),\n)).Handle(\"b\", func() { app.Go(\"home\") })\n\napp.Run()"
        }
      ]
    },
    {
      "name": "Attribute",
      "doc": "Attribute represents text styling attributes that can be combined.\n",
      "decl": "type Attribute uint8",
      "methods": [
        {
          "name": "Has",
          "doc": "Has returns true if the attribute set contains the given attribute.\n",
          "signature": "func (a Attribute) Has(attr Attribute) bool",
          "recv": "Attribute"
        },
        {
          "name": "With",
          "doc": "With returns a new attribute set with the given attribute added.\n",
          "signature": "func (a Attribute) With(attr Attribute) Attribute",
          "recv": "Attribute"
        },
        {
          "name": "Without",
          "doc": "Without returns a new attribute set with the given attribute removed.\n",
          "signature": "func (a Attribute) Without(attr Attribute) Attribute",
          "recv": "Attribute"
        }
      ],
      "consts": [
        {
          "doc": "",
          "names": [
            "AttrNone",
            "AttrBold",
            "AttrDim",
            "AttrItalic",
            "AttrUnderline",
            "AttrBlink",
            "AttrInverse",
            "AttrStrikethrough"
          ],
          "decl": "const (\n\tAttrNone Attribute = 0\n\tAttrBold Attribute = 1 \u003c\u003c iota\n\tAttrDim\n\tAttrItalic\n\tAttrUnderline\n\tAttrBlink\n\tAttrInverse\n\tAttrStrikethrough\n)"
        }
      ]
    },
    {
      "name": "AutoTableC",
      "doc": "",
      "decl": "type AutoTableC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "AutoTable",
          "doc": "AutoTable creates a table from a slice of structs.\nPass a slice like []MyStruct or []*MyStruct.\n",
          "signature": "func AutoTable(data any) AutoTableC",
          "examples": [
            {
              "doc": "Struct table.\nGenerate a table from a struct slice. Column options control formatting.\n",
              "code": "type Row struct {\n\tName string\n\tCPU  float64\n}\nrows := []Row{{Name: \"api\", CPU: 42.5}}\n\nAutoTable(\u0026rows).Column(\"CPU\", Number(1))"
            },
            {
              "name": "columns",
              "doc": "Column formatters.\nMix formatters: percentages, byte sizes, booleans, and colour-coded changes.\n",
              "code": "type Service struct {\n\tName   string\n\tCPU    float64\n\tMemory uint64\n\tActive bool\n\tGrowth float64\n}\nrows := []Service{\n\t{Name: \"api\", CPU: 82.3, Memory: 1073741824, Active: true, Growth: 0.12},\n}\n\nAutoTable(\u0026rows).\n\tColumn(\"CPU\", Percent(1)).\n\tColumn(\"Memory\", Bytes()).\n\tColumn(\"Active\", Bool(\"Yes\", \"No\")).\n\tColumn(\"Growth\", PercentChange(1))"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "AltRowStyle",
          "doc": "AltRowStyle sets the alternating row style.\n",
          "signature": "func (t AutoTableC) AltRowStyle(s Style) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for scrolling down/up by one row.\nthe closures capture the scroll pointer and data pointer, reading the\ncurrent slice length at invocation time for correct clamping.\n",
          "signature": "func (t AutoTableC) BindNav(down, up string) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "BindPageNav",
          "doc": "BindPageNav registers key bindings for page-sized scrolling.\n",
          "signature": "func (t AutoTableC) BindPageNav(pageDown, pageUp string) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "BindVimNav",
          "doc": "BindVimNav wires standard vim-style scroll keys:\nj/k for line, Ctrl-d/Ctrl-u for page.\n",
          "signature": "func (t AutoTableC) BindVimNav() AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (t AutoTableC) Border(b BorderStyle) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Column",
          "doc": "Column configures rendering for a specific column by struct field name.\nThe option can be a canned preset or a custom function:\n\n\tAutoTable(\u0026data).\n\t    Column(\"Price\", Currency(\"$\", 2)).\n\t    Column(\"Change\", PercentChange(1)).\n\t    Column(\"Active\", func(c *ColumnConfig) {\n\t        c.Align(AlignCenter)\n\t        c.Format(func(v any) string { ... })\n\t    })\n",
          "signature": "func (t AutoTableC) Column(name string, opt ColumnOption) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Columns",
          "doc": "Columns selects which struct fields to display and in what order.\nField names are case-sensitive and must match exported struct fields.\n",
          "signature": "func (t AutoTableC) Columns(names ...string) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between columns.\n",
          "signature": "func (t AutoTableC) Gap(g int8) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "HeaderStyle",
          "doc": "HeaderStyle sets the header row style.\n",
          "signature": "func (t AutoTableC) HeaderStyle(s Style) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Headers",
          "doc": "Headers sets custom header labels for the columns.\nMust be called after Columns() and have the same number of entries.\n",
          "signature": "func (t AutoTableC) Headers(names ...string) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (t AutoTableC) Margin(all int16) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (t AutoTableC) MarginTRBL(a, b, c, d int16) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (t AutoTableC) MarginVH(v, h int16) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "RowStyle",
          "doc": "RowStyle sets the default row style.\n",
          "signature": "func (t AutoTableC) RowStyle(s Style) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Scrollable",
          "doc": "Scrollable enables viewport scrolling with the given maximum visible rows.\nrenders all data rows to an internal buffer, blits only the visible window.\n",
          "signature": "func (t AutoTableC) Scrollable(maxVisible int) AutoTableC",
          "recv": "AutoTableC"
        },
        {
          "name": "Sortable",
          "doc": "Sortable enables column sorting via jump labels.\nwhen the app's jump key is pressed, each column header becomes a jump target.\nselecting a column sorts ascending; selecting the same column again toggles direction.\n",
          "signature": "func (t AutoTableC) Sortable() AutoTableC",
          "recv": "AutoTableC"
        }
      ]
    },
    {
      "name": "BoolValidator",
      "doc": "BoolValidator validates a boolean value.\n",
      "decl": "type BoolValidator func(bool) error"
    },
    {
      "name": "BorderStyle",
      "doc": "BorderStyle defines the characters used for drawing borders.\n",
      "decl": "type BorderStyle struct {\n\tHorizontal  rune\n\tVertical    rune\n\tTopLeft     rune\n\tTopRight    rune\n\tBottomLeft  rune\n\tBottomRight rune\n}",
      "examples": [
        {
          "doc": "Built-in borders.\nChoose from BorderSingle, BorderRounded, or BorderDouble.\n",
          "code": "VBox.Border(BorderDouble).BorderFG(Cyan)(\n\tText(\"double-bordered\"),\n)"
        },
        {
          "name": "custom",
          "doc": "Custom borders.\nDefine custom borders with any rune for each edge and corner.\n",
          "code": "ascii := BorderStyle{\n\tHorizontal:  '-',\n\tVertical:    '|',\n\tTopLeft:     '+',\n\tTopRight:    '+',\n\tBottomLeft:  '+',\n\tBottomRight: '+',\n}\n\nVBox.Border(ascii)(Text(\"ascii box\"))"
        }
      ]
    },
    {
      "name": "Box",
      "doc": "Box is a container with a custom layout function.\nUse this when HBox/VBox don't fit your needs.\n",
      "decl": "type Box struct {\n\tLayout   LayoutFunc\n\tChildren []any\n}"
    },
    {
      "name": "Buffer",
      "doc": "Buffer is a 2D grid of cells representing a drawable surface.\n",
      "decl": "type Buffer struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewBuffer",
          "doc": "NewBuffer creates a new buffer with the given dimensions.\n",
          "signature": "func NewBuffer(width, height int) *Buffer"
        }
      ],
      "methods": [
        {
          "name": "Blit",
          "doc": "Blit copies a rectangular region from src buffer to this buffer.\nsrcX, srcY: top-left corner in source buffer (for scrolling)\ndstX, dstY: top-left corner in destination buffer\nwidth, height: size of region to copy\nUses optimized row-by-row copy() for speed.\n",
          "signature": "func (b *Buffer) Blit(src *Buffer, srcX, srcY, dstX, dstY, width, height int)",
          "recv": "*Buffer"
        },
        {
          "name": "Clear",
          "doc": "Clear clears the buffer to empty cells with default style.\nUses copy() from a cached empty buffer for speed (memmove vs scalar loop).\n",
          "signature": "func (b *Buffer) Clear()",
          "recv": "*Buffer"
        },
        {
          "name": "ClearDirty",
          "doc": "ClearDirty clears only the rows that were written to since last clear.\nMuch faster than Clear() when content doesn't fill the buffer.\n",
          "signature": "func (b *Buffer) ClearDirty()",
          "recv": "*Buffer"
        },
        {
          "name": "ClearDirtyFlags",
          "doc": "ClearDirtyFlags resets all row dirty flags after a flush.\nCall this after Screen.Flush() to start tracking changes for next frame.\n",
          "signature": "func (b *Buffer) ClearDirtyFlags()",
          "recv": "*Buffer"
        },
        {
          "name": "ClearLine",
          "doc": "ClearLine clears a single line to empty cells.\n",
          "signature": "func (b *Buffer) ClearLine(y int)",
          "recv": "*Buffer"
        },
        {
          "name": "ClearLineWithStyle",
          "doc": "ClearLineWithStyle clears a single line with a styled space cell.\n",
          "signature": "func (b *Buffer) ClearLineWithStyle(y int, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "ContentHeight",
          "doc": "ContentHeight returns the number of rows that have been written to.\n",
          "signature": "func (b *Buffer) ContentHeight() int",
          "recv": "*Buffer"
        },
        {
          "name": "CopyFrom",
          "doc": "CopyFrom copies all cells from src to b using a single bulk copy.\nRequires both buffers to have identical dimensions.\nThis is much faster than cell-by-cell copy for full-buffer transfers.\n",
          "signature": "func (b *Buffer) CopyFrom(src *Buffer)",
          "recv": "*Buffer"
        },
        {
          "name": "DrawBorder",
          "doc": "DrawBorder draws a border around the given rectangle.\n",
          "signature": "func (b *Buffer) DrawBorder(x, y, width, height int, border BorderStyle, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "DrawPanel",
          "doc": "DrawPanel draws a bordered panel with title and returns the interior region.\nTitle appears in the top border: ┌─ TITLE ─────┐\n",
          "signature": "func (b *Buffer) DrawPanel(x, y, w, h int, title string, style Style) *Region",
          "recv": "*Buffer"
        },
        {
          "name": "DrawPanelEx",
          "doc": "DrawPanelEx draws a panel with custom border style.\n",
          "signature": "func (b *Buffer) DrawPanelEx(x, y, w, h int, title string, border BorderStyle, style Style) *Region",
          "recv": "*Buffer"
        },
        {
          "name": "Fill",
          "doc": "Fill fills the entire buffer with the given cell.\n",
          "signature": "func (b *Buffer) Fill(c Cell)",
          "recv": "*Buffer"
        },
        {
          "name": "FillRect",
          "doc": "FillRect fills a rectangular region with the given cell.\nUses direct slice writes (no border merge) for non-border cells,\nfalls back to Set() only when the cell is a border character.\n",
          "signature": "func (b *Buffer) FillRect(x, y, width, height int, c Cell)",
          "recv": "*Buffer"
        },
        {
          "name": "Get",
          "doc": "Get returns the cell at the given coordinates.\nReturns an empty cell if out of bounds.\n",
          "signature": "func (b *Buffer) Get(x, y int) Cell",
          "recv": "*Buffer"
        },
        {
          "name": "GetLine",
          "doc": "GetLine returns the content of a single line as a string (trimmed).\n",
          "signature": "func (b *Buffer) GetLine(y int) string",
          "recv": "*Buffer"
        },
        {
          "name": "GetLineStyled",
          "doc": "GetLineStyled returns a line with embedded ANSI escape codes for styles.\n",
          "signature": "func (b *Buffer) GetLineStyled(y int) string",
          "recv": "*Buffer"
        },
        {
          "name": "HLine",
          "doc": "HLine draws a horizontal line of the given rune.\n",
          "signature": "func (b *Buffer) HLine(x, y, length int, r rune, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "Height",
          "doc": "Height returns the buffer height.\n",
          "signature": "func (b *Buffer) Height() int",
          "recv": "*Buffer"
        },
        {
          "name": "InBounds",
          "doc": "InBounds returns true if the given coordinates are within the buffer.\n",
          "signature": "func (b *Buffer) InBounds(x, y int) bool",
          "recv": "*Buffer"
        },
        {
          "name": "MarkAllDirty",
          "doc": "MarkAllDirty forces all rows to be considered dirty.\nUseful after external modifications or for testing.\n",
          "signature": "func (b *Buffer) MarkAllDirty()",
          "recv": "*Buffer"
        },
        {
          "name": "Region",
          "doc": "Region creates a view into a rectangular region of the buffer.\n",
          "signature": "func (b *Buffer) Region(x, y, width, height int) *Region",
          "recv": "*Buffer"
        },
        {
          "name": "ResetDirtyMax",
          "doc": "ResetDirtyMax resets the dirty tracking without clearing content.\nUse when you know the template will overwrite all cells.\n",
          "signature": "func (b *Buffer) ResetDirtyMax()",
          "recv": "*Buffer"
        },
        {
          "name": "Resize",
          "doc": "Resize resizes the buffer to new dimensions.\nExisting content is preserved where it fits.\n",
          "signature": "func (b *Buffer) Resize(width, height int)",
          "recv": "*Buffer"
        },
        {
          "name": "RowDirty",
          "doc": "RowDirty returns true if the given row has been modified since last ClearDirtyFlags.\nIf allDirty is set (after Clear/Resize), all rows are considered dirty.\n",
          "signature": "func (b *Buffer) RowDirty(y int) bool",
          "recv": "*Buffer"
        },
        {
          "name": "Set",
          "doc": "Set sets the cell at the given coordinates.\nDoes nothing if out of bounds.\nWhen drawing border characters, automatically merges with existing borders.\n",
          "signature": "func (b *Buffer) Set(x, y int, c Cell)",
          "recv": "*Buffer"
        },
        {
          "name": "SetFast",
          "doc": "SetFast sets a cell without border merging. Use for text/progress where\nyou know the content isn't a border character.\n",
          "signature": "func (b *Buffer) SetFast(x, y int, c Cell)",
          "recv": "*Buffer"
        },
        {
          "name": "SetRune",
          "doc": "SetRune sets just the rune at the given coordinates, preserving style.\n",
          "signature": "func (b *Buffer) SetRune(x, y int, r rune)",
          "recv": "*Buffer"
        },
        {
          "name": "SetStyle",
          "doc": "SetStyle sets just the style at the given coordinates, preserving rune.\n",
          "signature": "func (b *Buffer) SetStyle(x, y int, s Style)",
          "recv": "*Buffer"
        },
        {
          "name": "Size",
          "doc": "Size returns the buffer dimensions.\n",
          "signature": "func (b *Buffer) Size() (width, height int)",
          "recv": "*Buffer"
        },
        {
          "name": "String",
          "doc": "String returns the buffer contents as a string (for testing/debugging).\nEach row is separated by a newline. Trailing spaces are preserved.\n",
          "signature": "func (b *Buffer) String() string",
          "recv": "*Buffer"
        },
        {
          "name": "StringTrimmed",
          "doc": "StringTrimmed returns the buffer contents with trailing spaces removed per line.\n",
          "signature": "func (b *Buffer) StringTrimmed() string",
          "recv": "*Buffer"
        },
        {
          "name": "VLine",
          "doc": "VLine draws a vertical line of the given rune.\n",
          "signature": "func (b *Buffer) VLine(x, y, length int, r rune, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "Width",
          "doc": "Width returns the buffer width.\n",
          "signature": "func (b *Buffer) Width() int",
          "recv": "*Buffer"
        },
        {
          "name": "WriteLeader",
          "doc": "WriteLeader writes \"Label.....Value\" format with fill characters.\nThe label is left-aligned, value is right-aligned, fill chars in between.\n",
          "signature": "func (b *Buffer) WriteLeader(x, y int, label, value string, width int, fill rune, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "WriteProgressBar",
          "doc": "WriteProgressBar writes a progress bar directly to the buffer.\nUses partial block characters for smooth sub-character precision.\nBackground color fills the empty space for seamless appearance.\nBatch write - much faster than per-cell Set calls.\n",
          "signature": "func (b *Buffer) WriteProgressBar(x, y, width int, ratio float32, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "WriteSpans",
          "doc": "WriteSpans writes multiple styled text spans sequentially.\nEach span has its own style. Spans are written left to right.\nHandles double-width CJK characters correctly.\n",
          "signature": "func (b *Buffer) WriteSpans(x, y int, spans []Span, maxWidth int)",
          "recv": "*Buffer"
        },
        {
          "name": "WriteSparkline",
          "doc": "WriteSparkline writes a sparkline chart using Unicode block characters.\n",
          "signature": "func (b *Buffer) WriteSparkline(x, y int, values []float64, width int, min, max float64, style Style)",
          "recv": "*Buffer"
        },
        {
          "name": "WriteString",
          "doc": "WriteString writes a string at the given coordinates with the given style.\nReturns the number of cells written.\n",
          "signature": "func (b *Buffer) WriteString(x, y int, s string, style Style) int",
          "recv": "*Buffer"
        },
        {
          "name": "WriteStringClipped",
          "doc": "WriteStringClipped writes a string, stopping at maxWidth.\nReturns the number of cells written.\n",
          "signature": "func (b *Buffer) WriteStringClipped(x, y int, s string, style Style, maxWidth int) int",
          "recv": "*Buffer"
        },
        {
          "name": "WriteStringFast",
          "doc": "WriteStringFast writes a string without border merging.\nDirect slice access for maximum speed.\n",
          "signature": "func (b *Buffer) WriteStringFast(x, y int, s string, style Style, maxWidth int)",
          "recv": "*Buffer"
        },
        {
          "name": "WriteStringPadded",
          "doc": "WriteStringPadded writes a string and pads with spaces to fill width.\nThis allows skipping Clear() when UI structure is stable.\n",
          "signature": "func (b *Buffer) WriteStringPadded(x, y int, s string, style Style, width int)",
          "recv": "*Buffer"
        }
      ]
    },
    {
      "name": "BufferPool",
      "doc": "BufferPool manages double-buffered rendering.\nSwap alternates between two buffers, clearing the inactive one\nsynchronously before making it current.\n",
      "decl": "type BufferPool struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewBufferPool",
          "doc": "NewBufferPool creates a double-buffered pool.\n",
          "signature": "func NewBufferPool(width, height int) *BufferPool"
        }
      ],
      "methods": [
        {
          "name": "Current",
          "doc": "Current returns the current buffer for rendering.\n",
          "signature": "func (p *BufferPool) Current() *Buffer",
          "recv": "*BufferPool"
        },
        {
          "name": "Height",
          "doc": "Height returns the buffer height.\n",
          "signature": "func (p *BufferPool) Height() int",
          "recv": "*BufferPool"
        },
        {
          "name": "Resize",
          "doc": "Resize resizes both buffers in the pool to new dimensions.\nCall this when the terminal is resized.\n",
          "signature": "func (p *BufferPool) Resize(width, height int)",
          "recv": "*BufferPool"
        },
        {
          "name": "Run",
          "doc": "Run executes a render loop until ctx is cancelled.\nEach frame the callback receives a pre-cleared buffer - do whatever you need with it.\n",
          "signature": "func (p *BufferPool) Run(ctx context.Context, frame func(buf *Buffer)) error",
          "recv": "*BufferPool"
        },
        {
          "name": "Stop",
          "doc": "Stop is a no-op kept for API compatibility.\n",
          "signature": "func (p *BufferPool) Stop()",
          "recv": "*BufferPool"
        },
        {
          "name": "Swap",
          "doc": "Swap switches to the other buffer.\nReturns the new current buffer (cleared and ready to use).\n",
          "signature": "func (p *BufferPool) Swap() *Buffer",
          "recv": "*BufferPool"
        },
        {
          "name": "Width",
          "doc": "Width returns the buffer width.\n",
          "signature": "func (p *BufferPool) Width() int",
          "recv": "*BufferPool"
        }
      ]
    },
    {
      "name": "Cell",
      "doc": "Cell represents a single character cell on the terminal.\n",
      "decl": "type Cell struct {\n\tRune  rune\n\tStyle Style\n}",
      "constructors": [
        {
          "name": "EmptyCell",
          "doc": "EmptyCell returns a cell with a space and default style.\n",
          "signature": "func EmptyCell() Cell"
        },
        {
          "name": "NewCell",
          "doc": "NewCell creates a cell with the given rune and style.\n",
          "signature": "func NewCell(r rune, style Style) Cell"
        }
      ],
      "methods": [
        {
          "name": "Equal",
          "doc": "Equal returns true if two cells are equal.\n",
          "signature": "func (c Cell) Equal(other Cell) bool",
          "recv": "Cell"
        }
      ]
    },
    {
      "name": "CheckListC",
      "doc": "CheckListC is a list with per-item checkboxes, similar to todo lists.\n",
      "decl": "type CheckListC[T any] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "CheckList",
          "doc": "CheckList creates a list where each item has a checkbox.\n",
          "signature": "func CheckList[T any](items *[]T) *CheckListC[T]",
          "examples": [
            {
              "doc": "Toggleable list.\nLike List, but each item has a toggleable checkbox. The Done field is toggled in place through the pointer.\n",
              "code": "type Task struct {\n\tName string\n\tDone bool\n}\ntasks := []Task{{Name: \"Ship it\"}, {Name: \"Test it\"}}\n\nCheckList(\u0026tasks).Render(func(t *Task) any {\n\treturn Text(\u0026t.Name)\n}).BindNav(\"j\", \"k\").BindToggle(\" \")"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BindDelete",
          "doc": "BindDelete registers a key binding to delete the selected item.\n",
          "signature": "func (c *CheckListC[T]) BindDelete(key string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "BindFirstLast",
          "doc": "BindFirstLast registers key bindings for jumping to first/last item.\n",
          "signature": "func (c *CheckListC[T]) BindFirstLast(first, last string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for moving selection down and up.\n",
          "signature": "func (c *CheckListC[T]) BindNav(down, up string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "BindPageNav",
          "doc": "BindPageNav registers key bindings for page-sized movement.\n",
          "signature": "func (c *CheckListC[T]) BindPageNav(pageDown, pageUp string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "BindToggle",
          "doc": "BindToggle registers a key binding to toggle the checked state.\n",
          "signature": "func (c *CheckListC[T]) BindToggle(key string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "BindVimNav",
          "doc": "BindVimNav wires the standard vim-style navigation keys:\nj/k for line movement, Ctrl-d/Ctrl-u for page, g/G for first/last.\n",
          "signature": "func (c *CheckListC[T]) BindVimNav() *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Checked",
          "doc": "Checked sets the function to get the checked state for each item.\n",
          "signature": "func (c *CheckListC[T]) Checked(fn func(*T) *bool) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Delete",
          "doc": "Delete removes the currently selected item.\n",
          "signature": "func (c *CheckListC[T]) Delete()",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Down",
          "doc": "Down moves selection down by one.\n",
          "signature": "func (c *CheckListC[T]) Down(m any)",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "First",
          "doc": "First moves selection to first item.\n",
          "signature": "func (c *CheckListC[T]) First(m any)",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between children.\n",
          "signature": "func (c *CheckListC[T]) Gap(g int8) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a key binding that passes the currently selected item\nto the callback. If nothing is selected, the callback is not called.\n",
          "signature": "func (c *CheckListC[T]) Handle(key string, fn func(*T)) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Index",
          "doc": "Index returns the current selection index.\n",
          "signature": "func (c *CheckListC[T]) Index() int",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Last",
          "doc": "Last moves selection to last item.\n",
          "signature": "func (c *CheckListC[T]) Last(m any)",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (c *CheckListC[T]) Margin(all int16) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (c *CheckListC[T]) MarginTRBL(t, r, b, l int16) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (c *CheckListC[T]) MarginVH(v, h int16) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Marker",
          "doc": "Marker sets the selection indicator.\n",
          "signature": "func (c *CheckListC[T]) Marker(m string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "MarkerStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (c *CheckListC[T]) MarkerStyle(s Style) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Marks",
          "doc": "Marks sets the checkbox characters.\n",
          "signature": "func (c *CheckListC[T]) Marks(checked, unchecked string) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "PageDown",
          "doc": "PageDown moves selection down by page size.\n",
          "signature": "func (c *CheckListC[T]) PageDown(m any)",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "PageUp",
          "doc": "PageUp moves selection up by page size.\n",
          "signature": "func (c *CheckListC[T]) PageUp(m any)",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (c *CheckListC[T]) Ref(f func(*CheckListC[T])) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Render",
          "doc": "Render sets a custom render function for item content (after the checkbox).\n",
          "signature": "func (c *CheckListC[T]) Render(fn func(*T) any) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Selected",
          "doc": "SelectedItem returns a pointer to the currently selected item.\n",
          "signature": "func (c *CheckListC[T]) Selected() *T",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "SelectedStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (c *CheckListC[T]) SelectedStyle(s Style) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (c *CheckListC[T]) Style(s Style) *CheckListC[T]",
          "recv": "*CheckListC[T]"
        },
        {
          "name": "Up",
          "doc": "Up moves selection up by one.\n",
          "signature": "func (c *CheckListC[T]) Up(m any)",
          "recv": "*CheckListC[T]"
        }
      ]
    },
    {
      "name": "CheckboxC",
      "doc": "CheckboxC is a toggleable checkbox bound to a *bool.\n",
      "decl": "type CheckboxC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Checkbox",
          "doc": "Checkbox creates a checkbox bound to a bool pointer.\n",
          "signature": "func Checkbox(checked *bool, label string) *CheckboxC",
          "examples": [
            {
              "doc": "Single checkbox.\nBound to a bool pointer.\n",
              "code": "var agreed bool\n\nCheckbox(\u0026agreed, \"I agree to the terms\")"
            }
          ]
        },
        {
          "name": "CheckboxPtr",
          "doc": "CheckboxPtr creates a checkbox with a dynamic label.\n",
          "signature": "func CheckboxPtr(checked *bool, label *string) *CheckboxC"
        }
      ],
      "methods": [
        {
          "name": "BindToggle",
          "doc": "BindToggle registers a key binding to toggle the checked state.\n",
          "signature": "func (c *CheckboxC) BindToggle(key string) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "Checked",
          "doc": "Checked returns the current state.\n",
          "signature": "func (c *CheckboxC) Checked() bool",
          "recv": "*CheckboxC"
        },
        {
          "name": "Err",
          "doc": "Err returns the current validation error message, or empty string if valid.\n",
          "signature": "func (c *CheckboxC) Err() string",
          "recv": "*CheckboxC"
        },
        {
          "name": "Focused",
          "doc": "Focused returns whether this checkbox currently has focus.\n",
          "signature": "func (c *CheckboxC) Focused() bool",
          "recv": "*CheckboxC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (c *CheckboxC) Margin(all int16) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (c *CheckboxC) MarginTRBL(t, r, b, l int16) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (c *CheckboxC) MarginVH(v, h int16) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "Marks",
          "doc": "Marks sets the checked and unchecked display characters.\n",
          "signature": "func (c *CheckboxC) Marks(checked, unchecked string) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (c *CheckboxC) Ref(f func(*CheckboxC)) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (c *CheckboxC) Style(s Style) *CheckboxC",
          "recv": "*CheckboxC"
        },
        {
          "name": "Toggle",
          "doc": "Toggle flips the checked state.\n",
          "signature": "func (c *CheckboxC) Toggle()",
          "recv": "*CheckboxC"
        },
        {
          "name": "Validate",
          "doc": "Validate sets a validation function and when it runs.\nIf when is omitted, defaults to VOnBlur|VOnSubmit.\n",
          "signature": "func (c *CheckboxC) Validate(fn BoolValidator, when ...ValidateOn) *CheckboxC",
          "recv": "*CheckboxC"
        }
      ]
    },
    {
      "name": "ChildSize",
      "doc": "ChildSize represents a child's computed minimum dimensions.\n",
      "decl": "type ChildSize struct {\n\tMinW, MinH int\n}"
    },
    {
      "name": "Color",
      "doc": "Color represents a terminal color.\n",
      "decl": "type Color struct {\n\tMode    ColorMode\n\tR, G, B uint8 // For RGB mode\n\tIndex   uint8 // For 16/256 mode\n}",
      "constructors": [
        {
          "name": "BasicColor",
          "doc": "BasicColor returns one of the 16 basic terminal colours.\n",
          "signature": "func BasicColor(index uint8) Color",
          "examples": [
            {
              "doc": "Terminal palette.\nBasicColor uses the terminal's 16-colour palette (0–15). These respect the user's terminal theme.\n",
              "code": "Text(\"theme-aware\").FG(BasicColor(9))"
            }
          ]
        },
        {
          "name": "DefaultColor",
          "doc": "DefaultColor returns the terminal's default color.\n",
          "signature": "func DefaultColor() Color"
        },
        {
          "name": "Hex",
          "doc": "Hex returns a 24-bit true color from a hex value (e.g., 0xFF5500).\n",
          "signature": "func Hex(hex uint32) Color",
          "examples": [
            {
              "doc": "Hex colour.\nTakes a uint32, not a string. Use Go hex literals.\n",
              "code": "Text(\"branded\").FG(Hex(0xFF5500))"
            }
          ]
        },
        {
          "name": "LerpColor",
          "doc": "LerpColor blends between two colours. t=0 returns a, t=1 returns b.\n",
          "signature": "func LerpColor(a, b Color, t float64) Color",
          "examples": [
            {
              "doc": "Colour blending.\nLerpColor blends two colours. t=0 returns the first, t=1 returns the second, 0.5 is the midpoint.\n",
              "code": "pct := 0.75\nbar := LerpColor(Red, Green, pct)\nText(\"75%\").FG(bar)"
            }
          ]
        },
        {
          "name": "PaletteColor",
          "doc": "PaletteColor returns one of the 256 palette colours.\n",
          "signature": "func PaletteColor(index uint8) Color",
          "examples": [
            {
              "doc": "Extended palette.\nPaletteColor uses the 256-colour extended palette.\n",
              "code": "Text(\"orange-ish\").FG(PaletteColor(214))"
            }
          ]
        },
        {
          "name": "RGB",
          "doc": "RGB returns a 24-bit true color.\n",
          "signature": "func RGB(r, g, b uint8) Color",
          "examples": [
            {
              "doc": "RGB colour.\nPrecise 24-bit colour from red, green, blue components.\n",
              "code": "Text(\"vivid\").FG(RGB(255, 85, 0))"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Equal",
          "doc": "Equal returns true if two colours are equal.\n",
          "signature": "func (c Color) Equal(other Color) bool",
          "recv": "Color"
        }
      ]
    },
    {
      "name": "ColorMode",
      "doc": "ColorMode represents the color mode for a color value.\n",
      "decl": "type ColorMode uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "ColorDefault",
            "Color16",
            "Color256",
            "ColorRGB"
          ],
          "decl": "const (\n\tColorDefault ColorMode = iota // Terminal default\n\tColor16                       // Basic 16 colours (0-15)\n\tColor256                      // 256 color palette (0-255)\n\tColorRGB                      // 24-bit true color\n)"
        }
      ]
    },
    {
      "name": "ColumnConfig",
      "doc": "ColumnConfig holds rendering configuration for one column.\n",
      "decl": "type ColumnConfig struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Align",
          "doc": "Align sets the column alignment.\n",
          "signature": "func (c *ColumnConfig) Align(a Align)",
          "recv": "*ColumnConfig"
        },
        {
          "name": "Format",
          "doc": "Format sets a function that converts the field value to display text.\n",
          "signature": "func (c *ColumnConfig) Format(fn func(any) string)",
          "recv": "*ColumnConfig"
        },
        {
          "name": "Style",
          "doc": "Style sets a function that returns a per-cell style based on the field value.\n",
          "signature": "func (c *ColumnConfig) Style(fn func(any) Style)",
          "recv": "*ColumnConfig"
        }
      ]
    },
    {
      "name": "ColumnOption",
      "doc": "ColumnOption configures a single AutoTable column.\n",
      "decl": "type ColumnOption func(*ColumnConfig)",
      "constructors": [
        {
          "name": "Bool",
          "doc": "Bool formats boolean values with custom labels.\n",
          "signature": "func Bool(yes, no string) ColumnOption"
        },
        {
          "name": "Bytes",
          "doc": "Bytes formats numeric values as human-readable byte sizes.\n",
          "signature": "func Bytes() ColumnOption"
        },
        {
          "name": "Currency",
          "doc": "Currency formats numeric values with a symbol prefix and comma\nseparators - it is by no means a full internationalization solution,\nbut it's a quick default.\n",
          "signature": "func Currency(symbol string, decimals int) ColumnOption",
          "examples": [
            {
              "doc": "Currency formatting.\nFormat a float as a monetary value with the given symbol and decimal places.\n",
              "code": "type Invoice struct {\n\tItem  string\n\tPrice float64\n}\nrows := []Invoice{{Item: \"Widget\", Price: 42.50}}\n\nAutoTable(\u0026rows).Column(\"Price\", Currency(\"$\", 2))"
            }
          ]
        },
        {
          "name": "Number",
          "doc": "Number formats numeric values with comma separators.\ndecimals controls decimal places for floats (ignored for integers).\n",
          "signature": "func Number(decimals int) ColumnOption"
        },
        {
          "name": "Percent",
          "doc": "Percent formats numeric values as percentages.\n",
          "signature": "func Percent(decimals int) ColumnOption"
        },
        {
          "name": "PercentChange",
          "doc": "PercentChange formats numeric values as signed percentages with green/red coloring.\n",
          "signature": "func PercentChange(decimals int) ColumnOption"
        },
        {
          "name": "StyleBool",
          "doc": "StyleBool colors cells based on a boolean value.\n",
          "signature": "func StyleBool(trueStyle, falseStyle Style) ColumnOption"
        },
        {
          "name": "StyleSign",
          "doc": "StyleSign colors cells based on the numeric sign of the value.\n",
          "signature": "func StyleSign(positive, negative Style) ColumnOption"
        },
        {
          "name": "StyleThreshold",
          "doc": "StyleThreshold colors cells based on numeric value thresholds.\nValues \u003c low get belowStyle, low..high get betweenStyle, \u003e high get aboveStyle.\n",
          "signature": "func StyleThreshold(low, high float64, belowStyle, betweenStyle, aboveStyle Style) ColumnOption"
        }
      ]
    },
    {
      "name": "Component",
      "doc": "Component is the extension interface for custom components.\nExternal packages can implement this to create custom components\nthat expand to built-in primitives at compile time.\n",
      "decl": "type Component interface {\n\tBuild() any\n}"
    },
    {
      "name": "Condition",
      "doc": "Condition builder for type-safe conditionals.\nThe generic *T parameter enforces pointer-passing at compile time.\n",
      "decl": "type Condition[T comparable] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "If",
          "doc": "If starts a conditional chain. Compile-time enforces pointer:\n\n\tIf(\u0026state.Count).Eq(0)    // works\n\tIf(state.Count).Eq(0)     // compile error: int is not *int\n",
          "signature": "func If[T comparable](ptr *T) *Condition[T]",
          "examples": [
            {
              "doc": "Conditional show.\nShow or hide content based on a bool pointer. The value is checked every frame.\n",
              "code": "show := true\nIf(\u0026show).Then(Text(\"visible\"))"
            },
            {
              "name": "else",
              "doc": "Toggle views.\nSwitch between two views based on state.\n",
              "code": "loggedIn := false\nIf(\u0026loggedIn).Then(Text(\"dashboard\")).Else(Text(\"login\"))"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Eq",
          "doc": "Eq checks equality: *ptr == val\n",
          "signature": "func (c *Condition[T]) Eq(val T) *ConditionEval[T]",
          "recv": "*Condition[T]"
        },
        {
          "name": "Ne",
          "doc": "Ne checks inequality: *ptr != val\n",
          "signature": "func (c *Condition[T]) Ne(val T) *ConditionEval[T]",
          "recv": "*Condition[T]"
        },
        {
          "name": "Then",
          "doc": "Then is shorthand for checking truthiness (not equal to zero value).\nFor bool: If(\u0026flag).Then(node) renders when flag is true\nFor int: If(\u0026count).Then(node) renders when count is non-zero\nFor string: If(\u0026str).Then(node) renders when str is non-empty\n",
          "signature": "func (c *Condition[T]) Then(node any) *ConditionEval[T]",
          "recv": "*Condition[T]"
        }
      ],
      "examples": [
        {
          "name": "eq",
          "doc": "Value matching.\nMatch against a specific value. Works with strings, ints, or any comparable type.\n",
          "code": "status := \"active\"\nIf(\u0026status).Eq(\"active\").Then(\n\tText(\"online\").FG(Green),\n).Else(\n\tText(\"offline\").FG(Red),\n)"
        }
      ]
    },
    {
      "name": "ConditionEval",
      "doc": "ConditionEval holds a comparable condition ready for Then/Else\n",
      "decl": "type ConditionEval[T comparable] struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Else",
          "doc": "Else specifies what to render when false\n",
          "signature": "func (e *ConditionEval[T]) Else(node any) *ConditionEval[T]",
          "recv": "*ConditionEval[T]"
        },
        {
          "name": "Then",
          "doc": "Then specifies what to render when true\n",
          "signature": "func (e *ConditionEval[T]) Then(node any) *ConditionEval[T]",
          "recv": "*ConditionEval[T]"
        }
      ]
    },
    {
      "name": "Cursor",
      "doc": "Cursor represents a cursor position and style.\nUse this to read full cursor state. For setting, use the individual\nmethods (SetCursor, SetCursorStyle, ShowCursor, HideCursor) which\nare optimized for their typical usage patterns.\n",
      "decl": "type Cursor struct {\n\tX, Y    int\n\tStyle   CursorShape\n\tVisible bool\n}",
      "constructors": [
        {
          "name": "DefaultCursor",
          "doc": "DefaultCursor returns a cursor with sensible defaults.\n",
          "signature": "func DefaultCursor() Cursor"
        }
      ]
    },
    {
      "name": "CursorShape",
      "doc": "CursorShape represents the terminal cursor shape.\n",
      "decl": "type CursorShape int",
      "consts": [
        {
          "doc": "",
          "names": [
            "CursorDefault",
            "CursorBlockBlink",
            "CursorBlock",
            "CursorUnderlineBlink",
            "CursorUnderline",
            "CursorBarBlink",
            "CursorBar"
          ],
          "decl": "const (\n\tCursorDefault        CursorShape = 0 // Terminal default\n\tCursorBlockBlink     CursorShape = 1 // Blinking block\n\tCursorBlock          CursorShape = 2 // Steady block\n\tCursorUnderlineBlink CursorShape = 3 // Blinking underline\n\tCursorUnderline      CursorShape = 4 // Steady underline\n\tCursorBarBlink       CursorShape = 5 // Blinking bar (line)\n\tCursorBar            CursorShape = 6 // Steady bar (line)\n)"
        }
      ]
    },
    {
      "name": "Custom",
      "doc": "Custom allows user-defined components without modifying the framework.\nUse this for specialized widgets that aren't covered by built-in primitives.\nNote: Custom components use function calls (not inlined like built-ins),\nbut with viewport culling this overhead is negligible.\n",
      "decl": "type Custom struct {\n\t// Measure returns natural (width, height) given available width.\n\t// Called during the measure phase of rendering.\n\tMeasure func(availW int16) (w, h int16)\n\n\t// Render draws the component to the buffer at the given position.\n\t// Called during the draw phase with computed geometry.\n\tRender func(buf *Buffer, x, y, w, h int16)\n}",
      "constructors": [
        {
          "name": "Widget",
          "doc": "Widget creates a fully custom component with explicit measure and render functions.\nUse this when you need complete control over sizing and drawing.\n\n\tWidget(\n\t    func(availW int16) (w, h int16) { return 20, 3 },\n\t    func(buf *Buffer, x, y, w, h int16) {\n\t        buf.WriteString(int(x), int(y), \"Custom!\", Style{})\n\t    },\n\t)\n",
          "signature": "func Widget(\n\tmeasure func(availW int16) (w, h int16),\n\trender func(buf *Buffer, x, y, w, h int16),\n) Custom",
          "examples": [
            {
              "doc": "Custom rendering.\nEscape hatch for custom rendering. Measure reports size, Render draws directly into the cell buffer.\n",
              "code": "Widget(\n\tfunc(availW int16) (w, h int16) { return availW, 1 },\n\tfunc(buf *Buffer, x, y, w, h int16) {\n\t\tfor i := int16(0); i \u003c w; i++ {\n\t\t\tbuf.Set(int(x+i), int(y), Cell{Rune: '='})\n\t\t}\n\t},\n)"
            }
          ]
        }
      ]
    },
    {
      "name": "ElseNode",
      "doc": "ElseNode renders when preceding If was false.\n",
      "decl": "type ElseNode struct {\n\tThen any\n}",
      "constructors": [
        {
          "name": "Else",
          "doc": "Else creates an else branch.\n",
          "signature": "func Else(then any) ElseNode"
        }
      ]
    },
    {
      "name": "Filter",
      "doc": "Filter provides fzf-style filtering mechanics for a slice of items.\nit handles query parsing, scoring, filtering and index mapping back to the\noriginal source slice. no UI opinions — bring your own rendering.\n\nusage:\n\n\tf := NewFilter(\u0026items, func(item *Item) string { return item.Name })\n\tf.Update(\"query\")           // re-filter when query changes\n\tf.Items                     // filtered+ranked subset — point a ListC at \u0026f.Items\n\tf.Original(selectedIndex)   // map filtered index back to source item\n",
      "decl": "type Filter[T any] struct {\n\tItems []T // filtered+ranked subset, safe to point a ListC at \u0026f.Items\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewFilter",
          "doc": "NewFilter creates a filter over a source slice.\nextract returns the searchable text for each item.\n",
          "signature": "func NewFilter[T any](source *[]T, extract func(*T) string) *Filter[T]"
        }
      ],
      "methods": [
        {
          "name": "Active",
          "doc": "Active reports whether a filter query is currently applied.\n",
          "signature": "func (f *Filter[T]) Active() bool",
          "recv": "*Filter[T]"
        },
        {
          "name": "Len",
          "doc": "Len returns the number of currently visible (filtered) items.\n",
          "signature": "func (f *Filter[T]) Len() int",
          "recv": "*Filter[T]"
        },
        {
          "name": "Original",
          "doc": "Original maps a filtered index back to a pointer into the source slice.\nreturns nil if the index is out of bounds.\n",
          "signature": "func (f *Filter[T]) Original(filteredIndex int) *T",
          "recv": "*Filter[T]"
        },
        {
          "name": "OriginalIndex",
          "doc": "OriginalIndex maps a filtered index back to the index in the source slice.\nreturns -1 if the index is out of bounds.\n",
          "signature": "func (f *Filter[T]) OriginalIndex(filteredIndex int) int",
          "recv": "*Filter[T]"
        },
        {
          "name": "Query",
          "doc": "Query returns the current raw query string.\n",
          "signature": "func (f *Filter[T]) Query() string",
          "recv": "*Filter[T]"
        },
        {
          "name": "Reset",
          "doc": "Reset clears the filter, restoring all source items in original order.\n",
          "signature": "func (f *Filter[T]) Reset()",
          "recv": "*Filter[T]"
        },
        {
          "name": "Update",
          "doc": "Update re-filters the source slice with a new query string.\nno-op if the query hasn't changed.\n",
          "signature": "func (f *Filter[T]) Update(query string)",
          "recv": "*Filter[T]"
        }
      ]
    },
    {
      "name": "FilterListC",
      "doc": "FilterListC is a drop-in filterable list. it composes an input, a\nfilter and a list into a single template node.\n\nusage:\n\n\tFilterList(\u0026items, func(p *Profile) string { return p.Name }).\n\t    Placeholder(\"filter...\").\n\t    Render(func(p *Profile) any { return Text(p.Name) }).\n\t    MaxVisible(20).\n\t    Handle(\"\u003cEnter\u003e\", func(p *Profile) { ... })\n",
      "decl": "type FilterListC[T any] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "FilterList",
          "doc": "FilterList creates a filterable list.\nextract returns the searchable text for each item.\n",
          "signature": "func FilterList[T any](source *[]T, extract func(*T) string) *FilterListC[T]",
          "examples": [
            {
              "doc": "Searchable list.\nThe extract function tells the filter which string to match against for each item.\n",
              "code": "items := []string{\"Alpha\", \"Beta\", \"Gamma\"}\n\nFilterList(\u0026items, func(s *string) string { return *s }).\n\tRender(func(item *string) any {\n\t\treturn Text(item)\n\t})"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Active",
          "doc": "Active reports whether a filter query is currently applied.\n",
          "signature": "func (fl *FilterListC[T]) Active() bool",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "BindNav",
          "doc": "BindNav overrides the default navigation keys.\n",
          "signature": "func (fl *FilterListC[T]) BindNav(down, up string) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (fl *FilterListC[T]) Border(b BorderStyle) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Clear",
          "doc": "Clear resets the filter and input.\n",
          "signature": "func (fl *FilterListC[T]) Clear()",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Filter",
          "doc": "Filter returns the underlying Filter for direct access.\n",
          "signature": "func (fl *FilterListC[T]) Filter() *Filter[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a key binding that passes the currently selected\noriginal source item to the callback.\n",
          "signature": "func (fl *FilterListC[T]) Handle(key string, fn func(*T)) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "HandleClear",
          "doc": "HandleClear registers a key that clears the filter when active,\nor calls the fallback when no filter is applied.\n",
          "signature": "func (fl *FilterListC[T]) HandleClear(key string, fallback func()) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (fl *FilterListC[T]) Margin(all int16) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (fl *FilterListC[T]) MarginTRBL(t, r, b, l int16) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (fl *FilterListC[T]) MarginVH(v, h int16) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Marker",
          "doc": "Marker sets the selection marker (default \"\u003e \").\n",
          "signature": "func (fl *FilterListC[T]) Marker(m string) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "MaxVisible",
          "doc": "MaxVisible sets the maximum number of visible items.\n",
          "signature": "func (fl *FilterListC[T]) MaxVisible(n int) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Placeholder",
          "doc": "Placeholder sets the input placeholder text.\n",
          "signature": "func (fl *FilterListC[T]) Placeholder(p string) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the FilterListC for external references.\n",
          "signature": "func (fl *FilterListC[T]) Ref(f func(*FilterListC[T])) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Render",
          "doc": "Render sets the render function for each list item.\n",
          "signature": "func (fl *FilterListC[T]) Render(fn func(*T) any) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Selected",
          "doc": "Selected returns a pointer to the original source item corresponding\nto the current list selection. returns nil if nothing is selected.\n",
          "signature": "func (fl *FilterListC[T]) Selected() *T",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "SelectedIndex",
          "doc": "SelectedIndex returns the index into the original source slice.\nreturns -1 if nothing is selected.\n",
          "signature": "func (fl *FilterListC[T]) SelectedIndex() int",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "SelectedStyle",
          "doc": "SelectedStyle sets the style for the selected row.\n",
          "signature": "func (fl *FilterListC[T]) SelectedStyle(s Style) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Style",
          "doc": "Style sets the default style for non-selected rows.\n",
          "signature": "func (fl *FilterListC[T]) Style(s Style) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        },
        {
          "name": "Title",
          "doc": "Title sets the border title.\n",
          "signature": "func (fl *FilterListC[T]) Title(t string) *FilterListC[T]",
          "recv": "*FilterListC[T]"
        }
      ]
    },
    {
      "name": "FilterLogC",
      "doc": "FilterLogC is a filterable log viewer. It composes an input and a log\ninto a single component with fzf-style filtering.\n\nusage:\n\n\tFilterLog(reader).\n\t    Placeholder(\"filter...\").\n\t    MaxLines(10000).\n\t    BindVimNav()\n",
      "decl": "type FilterLogC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "FilterLog",
          "doc": "FilterLog creates a filterable log viewer.\n",
          "signature": "func FilterLog(r io.Reader) *FilterLogC"
        }
      ],
      "methods": [
        {
          "name": "Active",
          "doc": "Active reports whether a filter is currently applied.\n",
          "signature": "func (fl *FilterLogC) Active() bool",
          "recv": "*FilterLogC"
        },
        {
          "name": "BindFirstLast",
          "doc": "BindFirstLast registers key bindings for jumping to top/bottom.\n",
          "signature": "func (fl *FilterLogC) BindFirstLast(first, last string) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for scrolling.\n",
          "signature": "func (fl *FilterLogC) BindNav(down, up string) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "BindPageNav",
          "doc": "BindPageNav registers key bindings for half-page scrolling.\n",
          "signature": "func (fl *FilterLogC) BindPageNav(down, up string) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "BindVimNav",
          "doc": "BindVimNav wires vim-style scroll keys (overrides defaults).\n",
          "signature": "func (fl *FilterLogC) BindVimNav() *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "Clear",
          "doc": "Clear resets the filter input.\n",
          "signature": "func (fl *FilterLogC) Clear()",
          "recv": "*FilterLogC"
        },
        {
          "name": "Focused",
          "doc": "Focused returns whether this FilterLog currently has focus.\n",
          "signature": "func (fl *FilterLogC) Focused() bool",
          "recv": "*FilterLogC"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (fl *FilterLogC) Grow(g float32) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "Layer",
          "doc": "Layer returns the underlying layer for scroll info.\n",
          "signature": "func (fl *FilterLogC) Layer() *Layer",
          "recv": "*FilterLogC"
        },
        {
          "name": "ManagedBy",
          "doc": "ManagedBy registers this FilterLog with a FocusManager.\n",
          "signature": "func (fl *FilterLogC) ManagedBy(fm *FocusManager) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (fl *FilterLogC) Margin(all int16) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (fl *FilterLogC) MarginTRBL(t, r, b, l int16) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (fl *FilterLogC) MarginVH(v, h int16) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "MaxLines",
          "doc": "MaxLines sets the maximum number of lines to keep in the buffer.\n",
          "signature": "func (fl *FilterLogC) MaxLines(n int) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "NewLines",
          "doc": "NewLines returns the number of new lines while not following.\n",
          "signature": "func (fl *FilterLogC) NewLines() int",
          "recv": "*FilterLogC"
        },
        {
          "name": "Placeholder",
          "doc": "Placeholder sets the input placeholder text.\n",
          "signature": "func (fl *FilterLogC) Placeholder(p string) *FilterLogC",
          "recv": "*FilterLogC"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the FilterLogC for external references.\n",
          "signature": "func (fl *FilterLogC) Ref(f func(*FilterLogC)) *FilterLogC",
          "recv": "*FilterLogC"
        }
      ],
      "examples": [
        {
          "doc": "Filterable log.\nA log view with a built-in fuzzy search input. Lines are filtered as you type; matching is fzf-style.\n",
          "code": "r := strings.NewReader(\"info: started\\nerror: failed\\ninfo: recovered\\n\")\n\nFilterLog(r).Placeholder(\"filter logs...\").MaxLines(5000).BindVimNav()"
        }
      ]
    },
    {
      "name": "Flex",
      "doc": "Flex contains layout properties for display components.\nEmbedded in Row, Col, Text, etc. for consistent layout behavior.\nLayout only - no visual styling here.\n",
      "decl": "type Flex struct {\n\tPercentWidth float32 // fraction of parent width (0.5 = 50%)\n\tWidth        int16   // explicit width in characters\n\tHeight       int16   // explicit height in lines\n\tFlexGrow     float32 // share of remaining space (0 = none, 1 = equal share)\n}"
    },
    {
      "name": "FlushStats",
      "doc": "FlushStats holds statistics from the last flush.\n",
      "decl": "type FlushStats struct {\n\tDirtyRows   int\n\tChangedRows int\n}",
      "constructors": [
        {
          "name": "GetFlushStats",
          "doc": "GetFlushStats returns stats from the last flush.\n",
          "signature": "func GetFlushStats() FlushStats"
        }
      ]
    },
    {
      "name": "FocusGroup",
      "doc": "FocusGroup tracks which field in a group is focused.\nShare a single FocusGroup across multiple inputs.\n",
      "decl": "type FocusGroup struct {\n\tCurrent int\n}"
    },
    {
      "name": "FocusManager",
      "doc": "FocusManager coordinates keyboard focus across multiple components.\nIt automatically wires Tab/Shift-Tab for focus cycling and routes\nkeystrokes to the currently focused component.\n\nusage:\n\n\tfm := NewFocusManager()\n\tname := Input().Placeholder(\"Name\").ManagedBy(fm)\n\temail := Input().Placeholder(\"Email\").ManagedBy(fm)\n\tapp.SetView(VBox(name, email))\n",
      "decl": "type FocusManager struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewFocusManager",
          "doc": "NewFocusManager creates a new focus manager with default Tab/Shift-Tab bindings.\n",
          "signature": "func NewFocusManager() *FocusManager"
        }
      ],
      "methods": [
        {
          "name": "BlurCurrent",
          "doc": "BlurCurrent unfocuses the current item and pops its sub-router.\n",
          "signature": "func (fm *FocusManager) BlurCurrent()",
          "recv": "*FocusManager"
        },
        {
          "name": "Current",
          "doc": "Current returns the currently focused index.\n",
          "signature": "func (fm *FocusManager) Current() int",
          "recv": "*FocusManager"
        },
        {
          "name": "Focus",
          "doc": "Focus sets focus to a specific index.\n",
          "signature": "func (fm *FocusManager) Focus(index int)",
          "recv": "*FocusManager"
        },
        {
          "name": "HandleKey",
          "doc": "HandleKey routes a key to the currently focused component.\n",
          "signature": "func (fm *FocusManager) HandleKey(k riffkey.Key) bool",
          "recv": "*FocusManager"
        },
        {
          "name": "ItemBindings",
          "doc": "ItemBindings adds bindings to the most recently registered item's sub-router.\n",
          "signature": "func (fm *FocusManager) ItemBindings(binds ...binding)",
          "recv": "*FocusManager"
        },
        {
          "name": "Next",
          "doc": "Next moves focus to the next component.\n",
          "signature": "func (fm *FocusManager) Next()",
          "recv": "*FocusManager"
        },
        {
          "name": "NextKey",
          "doc": "NextKey sets the key binding for moving to the next focusable (default: Tab).\n",
          "signature": "func (fm *FocusManager) NextKey(key string) *FocusManager",
          "recv": "*FocusManager"
        },
        {
          "name": "OnBlur",
          "doc": "OnBlur sets a callback that fires when all items lose focus (via BlurCurrent).\n",
          "signature": "func (fm *FocusManager) OnBlur(fn func()) *FocusManager",
          "recv": "*FocusManager"
        },
        {
          "name": "OnChange",
          "doc": "OnChange sets a callback that fires when focus changes.\n",
          "signature": "func (fm *FocusManager) OnChange(fn func(index int)) *FocusManager",
          "recv": "*FocusManager"
        },
        {
          "name": "Prev",
          "doc": "Prev moves focus to the previous component.\n",
          "signature": "func (fm *FocusManager) Prev()",
          "recv": "*FocusManager"
        },
        {
          "name": "PrevKey",
          "doc": "PrevKey sets the key binding for moving to the previous focusable (default: Shift-Tab).\n",
          "signature": "func (fm *FocusManager) PrevKey(key string) *FocusManager",
          "recv": "*FocusManager"
        },
        {
          "name": "Register",
          "doc": "Register adds a focusable component to the manager.\nThe first registered component receives initial focus.\n",
          "signature": "func (fm *FocusManager) Register(f focusable) *FocusManager",
          "recv": "*FocusManager"
        }
      ],
      "examples": [
        {
          "doc": "Focu cycling.\nFocusManager coordinates focus between multiple inputs. Tab/Shift-Tab cycles through ManagedBy components.\n",
          "code": "fm := NewFocusManager()\n\nVBox(\n\tInput().Placeholder(\"Name\").ManagedBy(fm),\n\tInput().Placeholder(\"Email\").ManagedBy(fm),\n)"
        }
      ]
    },
    {
      "name": "ForEachC",
      "doc": "",
      "decl": "type ForEachC[T any] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "ForEach",
          "doc": "ForEach renders a template for each item in a slice.\n",
          "signature": "func ForEach[T any](items *[]T, template func(item *T) any) ForEachC[T]",
          "examples": [
            {
              "doc": "Slice iteration.\nIterate a slice with per-item templates. The callback receives a pointer to each item.\n",
              "code": "type Todo struct {\n\tTitle string\n\tDone  bool\n}\nitems := []Todo{{Title: \"Ship it\"}, {Title: \"Test it\"}}\n\nForEach(\u0026items, func(item *Todo) any {\n\treturn HBox.Gap(2)(\n\t\tCheckbox(\u0026item.Done, \"\"),\n\t\tText(\u0026item.Title),\n\t)\n})"
            }
          ]
        }
      ]
    },
    {
      "name": "ForEachNode",
      "doc": "ForEachNode iterates over a slice.\n",
      "decl": "type ForEachNode struct {\n\tItems  any // *[]T\n\tRender any // func(*T) any\n}"
    },
    {
      "name": "FormC",
      "doc": "FormC is a higher-order form component that arranges labeled fields\nin a vertical layout with aligned labels and automatic focus management.\n\nusage:\n\n\tForm.LabelBold().OnSubmit(register)(\n\t    Field(\"Name\", Input().Placeholder(\"Enter your name\")),\n\t    Field(\"Email\", Input().Placeholder(\"you@example.com\")),\n\t    Field(\"Password\", Input().Placeholder(\"password\").Mask('*')),\n\t)\n",
      "decl": "type FormC struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "FocusManager",
          "doc": "FocusManager returns the internal focus manager for external wiring.\n",
          "signature": "func (f *FormC) FocusManager() *FocusManager",
          "recv": "*FormC"
        },
        {
          "name": "ValidateAll",
          "doc": "ValidateAll runs validation on all fields that have VOnSubmit set.\nReturns true if all fields are valid.\n",
          "signature": "func (f *FormC) ValidateAll() bool",
          "recv": "*FormC"
        }
      ]
    },
    {
      "name": "FormField",
      "doc": "FormField pairs a label with an input control.\n",
      "decl": "type FormField struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Field",
          "doc": "Field creates a form field pairing a label with any control component.\n",
          "signature": "func Field(label string, control any) FormField"
        }
      ]
    },
    {
      "name": "FormFn",
      "doc": "FormFn is a configurable constructor for forms.\nConfigure with methods, then call with fields — same pattern as VBox/HBox.\n",
      "decl": "type FormFn func(fields ...FormField) *FormC",
      "methods": [
        {
          "name": "Gap",
          "doc": "Gap sets the vertical gap between fields.\n",
          "signature": "func (f FormFn) Gap(g int8) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (f FormFn) Grow(g float32) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "LabelBold",
          "doc": "LabelBold sets labels to bold.\n",
          "signature": "func (f FormFn) LabelBold() FormFn",
          "recv": "FormFn"
        },
        {
          "name": "LabelFG",
          "doc": "LabelFG sets the foreground color for all labels.\n",
          "signature": "func (f FormFn) LabelFG(c Color) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "LabelStyle",
          "doc": "LabelStyle sets the full style for all labels.\n",
          "signature": "func (f FormFn) LabelStyle(s Style) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "Margin",
          "doc": "Margin sets equal margin on all sides.\n",
          "signature": "func (f FormFn) Margin(m int16) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets top, right, bottom, left margin individually.\n",
          "signature": "func (f FormFn) MarginTRBL(t, r, b, l int16) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (f FormFn) MarginVH(v, h int16) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "NextKey",
          "doc": "NextKey sets the key for advancing focus (default: Tab).\n",
          "signature": "func (f FormFn) NextKey(key string) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "OnFocusChange",
          "doc": "OnFocusChange sets a callback that fires when focus changes.\n",
          "signature": "func (f FormFn) OnFocusChange(fn func(index int)) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "OnSubmit",
          "doc": "OnSubmit sets a callback that fires when Enter is pressed.\n",
          "signature": "func (f FormFn) OnSubmit(fn func()) FormFn",
          "recv": "FormFn"
        },
        {
          "name": "PrevKey",
          "doc": "PrevKey sets the key for reversing focus (default: Shift-Tab).\n",
          "signature": "func (f FormFn) PrevKey(key string) FormFn",
          "recv": "FormFn"
        }
      ],
      "vars": [
        {
          "doc": "Form creates a form from labeled fields.\nAutomatically creates a FocusManager and wires any focusable controls.\n",
          "names": [
            "Form"
          ],
          "decl": "var Form FormFn = func(fields ...FormField) *FormC {\n\tf := \u0026FormC{\n\t\tfields: fields,\n\t\tfm:     NewFocusManager(),\n\t}\n\n\tfor _, ff := range fields {\n\t\tw := int16(len(ff.label) + 1)\n\t\tif w \u003e f.labelWidth {\n\t\t\tf.labelWidth = w\n\t\t}\n\t}\n\n\t// auto-wire focusable controls and blur validation\n\tvar focusableFields []*FormField // maps FM index → FormField\n\tfor idx := range fields {\n\t\tff := \u0026f.fields[idx]\n\t\tif fc, ok := ff.control.(focusable); ok {\n\t\t\tfieldRef := ff\n\t\t\tfocusableFields = append(focusableFields, fieldRef)\n\t\t\tswitch ctrl := ff.control.(type) {\n\t\t\tcase *InputC:\n\t\t\t\tctrl.ManagedBy(f.fm)\n\t\t\t\tctrl.onBlur = func() {\n\t\t\t\t\tfieldRef.err = ctrl.Err()\n\t\t\t\t}\n\t\t\tcase *CheckboxC:\n\t\t\t\tf.fm.Register(fc)\n\t\t\t\tctrl.onBlur = func() {\n\t\t\t\t\tfieldRef.err = ctrl.Err()\n\t\t\t\t}\n\t\t\t\tf.fm.ItemBindings(\n\t\t\t\t\tbinding{pattern: \"\u003cSpace\u003e\", handler: func() { ctrl.Toggle() }},\n\t\t\t\t)\n\t\t\tcase *RadioC:\n\t\t\t\tf.fm.Register(fc)\n\t\t\t\tf.fm.ItemBindings(\n\t\t\t\t\tbinding{pattern: \"j\", handler: func() { ctrl.Next() }},\n\t\t\t\t\tbinding{pattern: \"k\", handler: func() { ctrl.Prev() }},\n\t\t\t\t)\n\t\t\tdefault:\n\t\t\t\tf.fm.Register(fc)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(focusableFields) \u003e 0 {\n\t\tfocusableFields[0].focused = true\n\t}\n\n\tf.fm.OnChange(func(idx int) {\n\t\tfor i, ff := range focusableFields {\n\t\t\tff.focused = (i == idx)\n\t\t}\n\t})\n\tf.fm.OnBlur(func() {\n\t\tfor _, ff := range focusableFields {\n\t\t\tff.focused = false\n\t\t}\n\t})\n\n\treturn f\n}"
        }
      ],
      "examples": [
        {
          "doc": "Registration form.\nForm arranges labeled fields with aligned labels and automatic focus management. Mix inputs, checkboxes and validators.\n",
          "code": "var name, email, pass string\nvar terms bool\n\nForm.LabelBold().Gap(1)(\n\tField(\"Name\", Input(\u0026name).Placeholder(\"Jane Doe\")),\n\tField(\"Email\", Input(\u0026email).Placeholder(\"jane@example.com\")),\n\tField(\"Password\", Input(\u0026pass).Placeholder(\"min 8 chars\").Mask('*')),\n\tField(\"Terms\", Checkbox(\u0026terms, \"I agree\")),\n)"
        },
        {
          "name": "mixedControls",
          "doc": "Mixed control types.\nInputs, checkboxes and radio groups all work as form fields with automatic focus cycling.\n",
          "code": "var name string\nvar notify bool\nvar role int\n\nForm.LabelBold().Gap(1)(\n\tField(\"Name\", Input(\u0026name).Placeholder(\"you\")),\n\tField(\"Notify\", Checkbox(\u0026notify, \"Send me updates\")),\n\tField(\"Role\", Radio(\u0026role, \"Viewer\", \"Editor\", \"Admin\")),\n)"
        },
        {
          "name": "onSubmit",
          "doc": "Submit handler.\nForward-declare the form variable so OnSubmit can reference the same instance.\n",
          "code": "var name, email, pass string\nvar terms bool\nvar form *FormC\n\nform = Form.LabelBold().OnSubmit(func() {\n\t_ = form.ValidateAll()\n})(\n\tField(\"Name\", Input(\u0026name).Validate(VRequired)),\n\tField(\"Email\", Input(\u0026email).Validate(VEmail)),\n\tField(\"Password\", Input(\u0026pass).Mask('*').Validate(VMinLen(8))),\n\tField(\"Terms\", Checkbox(\u0026terms, \"I agree\").Validate(VTrue)),\n)\n_ = form"
        }
      ]
    },
    {
      "name": "FzfQuery",
      "doc": "FzfQuery is a pre-parsed fzf query. parse once, score many.\n",
      "decl": "type FzfQuery struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "ParseFzfQuery",
          "doc": "ParseFzfQuery parses a raw query string into a reusable FzfQuery.\n",
          "signature": "func ParseFzfQuery(raw string) FzfQuery"
        }
      ],
      "methods": [
        {
          "name": "Empty",
          "doc": "Empty reports whether the query has no terms.\n",
          "signature": "func (q *FzfQuery) Empty() bool",
          "recv": "*FzfQuery"
        },
        {
          "name": "Score",
          "doc": "Score scores a single candidate against the parsed query.\nreturns (score, matched). higher score = better match.\n",
          "signature": "func (q *FzfQuery) Score(candidate string) (int, bool)",
          "recv": "*FzfQuery"
        }
      ]
    },
    {
      "name": "Geom",
      "doc": "Geom holds runtime geometry for an op.\nFilled during execute, parallel array to ops.\n",
      "decl": "type Geom struct {\n\tW, H           int16 // dimensions\n\tLocalX, LocalY int16 // position relative to parent\n\tContentH       int16 // natural content height (before flex distribution)\n}"
    },
    {
      "name": "HBoxC",
      "doc": "",
      "decl": "type HBoxC struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "HBoxFn",
      "doc": "",
      "decl": "type HBoxFn func(children ...any) HBoxC",
      "methods": [
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (f HBoxFn) Border(b BorderStyle) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "BorderBG",
          "doc": "BG sets the background color.\n",
          "signature": "func (f HBoxFn) BorderBG(c Color) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "BorderFG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (f HBoxFn) BorderFG(c Color) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "CascadeStyle",
          "doc": "CascadeStyle sets a style pointer that children inherit.\n",
          "signature": "func (f HBoxFn) CascadeStyle(s *Style) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Fill",
          "doc": "Fill sets the background fill color.\n",
          "signature": "func (f HBoxFn) Fill(c Color) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "FitContent",
          "doc": "FitContent sizes the container to fit its content.\n",
          "signature": "func (f HBoxFn) FitContent() HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between children.\n",
          "signature": "func (f HBoxFn) Gap(g int8) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (f HBoxFn) Grow(g float32) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Height",
          "doc": "Height sets a fixed height.\n",
          "signature": "func (f HBoxFn) Height(h int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (f HBoxFn) Margin(all int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (f HBoxFn) MarginTRBL(top, right, bottom, left int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (f HBoxFn) MarginVH(vertical, horizontal int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Size",
          "doc": "Size sets a fixed width and height.\n",
          "signature": "func (f HBoxFn) Size(w, h int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Title",
          "doc": "Title sets the border title text.\n",
          "signature": "func (f HBoxFn) Title(t string) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (f HBoxFn) Width(w int16) HBoxFn",
          "recv": "HBoxFn"
        },
        {
          "name": "WidthPct",
          "doc": "WidthPct sets width as a percentage of the parent (0.0-1.0).\n",
          "signature": "func (f HBoxFn) WidthPct(pct float32) HBoxFn",
          "recv": "HBoxFn"
        }
      ],
      "vars": [
        {
          "doc": "HBox is the horizontal container constructor\n",
          "names": [
            "HBox"
          ],
          "decl": "var HBox HBoxFn = func(children ...any) HBoxC {\n\treturn HBoxC{children: children}\n}"
        }
      ],
      "examples": [
        {
          "doc": "Horizontal layout.\nArrange children side by side with a gap between them.\n",
          "code": "HBox.Gap(2)(\n\tText(\"left\"),\n\tText(\"right\"),\n)"
        },
        {
          "name": "widths",
          "doc": "Sidebar pattern.\nCombine WidthPct and Grow for a fixed sidebar with a flexible main area.\n",
          "code": "HBox(\n\tVBox.WidthPct(30)(Text(\"sidebar\")),\n\tVBox.Grow(1)(Text(\"main content\")),\n)"
        }
      ]
    },
    {
      "name": "HBoxNode",
      "doc": "HBoxNode arranges children horizontally.\n",
      "decl": "type HBoxNode struct {\n\tChildren     []any\n\tTitle        string // title for bordered containers\n\tGap          int8\n\tCascadeStyle *Style // style inherited by children (pointer for dynamic themes)\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (r HBoxNode) Border(b BorderStyle) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "BorderBG",
          "doc": "BorderBG sets the border background color.\n",
          "signature": "func (r HBoxNode) BorderBG(c Color) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "BorderFG",
          "doc": "BorderFG sets the border foreground color.\n",
          "signature": "func (r HBoxNode) BorderFG(c Color) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "Grow",
          "doc": "Grow sets flex grow factor.\n",
          "signature": "func (r HBoxNode) Grow(g float32) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "Height",
          "doc": "Height sets explicit height in lines.\n",
          "signature": "func (r HBoxNode) Height(h int16) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (r HBoxNode) Margin(all int16) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for each side.\n",
          "signature": "func (r HBoxNode) MarginTRBL(top, right, bottom, left int16) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (r HBoxNode) MarginVH(vertical, horizontal int16) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "Width",
          "doc": "Width sets explicit width in characters.\n",
          "signature": "func (r HBoxNode) Width(w int16) HBoxNode",
          "recv": "HBoxNode"
        },
        {
          "name": "WidthPct",
          "doc": "WidthPct sets width as percentage of parent (0.5 = 50%).\n",
          "signature": "func (r HBoxNode) WidthPct(pct float32) HBoxNode",
          "recv": "HBoxNode"
        }
      ]
    },
    {
      "name": "HRuleC",
      "doc": "",
      "decl": "type HRuleC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "HRule",
          "doc": "HRule creates a horizontal rule.\n",
          "signature": "func HRule() HRuleC",
          "examples": [
            {
              "doc": "Horizontal divider.\nA line that fills the available width.\n",
              "code": "VBox(\n\tText(\"above\"),\n\tHRule(),\n\tText(\"below\"),\n)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (h HRuleC) BG(c Color) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (h HRuleC) Bold() HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "Char",
          "doc": "Char sets the display character.\n",
          "signature": "func (h HRuleC) Char(c rune) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (h HRuleC) FG(c Color) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (h HRuleC) Margin(all int16) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (h HRuleC) MarginTRBL(a, b, c, d int16) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (h HRuleC) MarginVH(v, hz int16) HRuleC",
          "recv": "HRuleC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (h HRuleC) Style(s Style) HRuleC",
          "recv": "HRuleC"
        }
      ]
    },
    {
      "name": "HRuleNode",
      "doc": "HRuleNode draws a horizontal line that fills available width.\nDefault character is '─' (box drawing light horizontal).\n",
      "decl": "type HRuleNode struct {\n\tChar  rune  // line character (0 = '─')\n\tStyle Style // styling\n}"
    },
    {
      "name": "IfNode",
      "doc": "IfNode conditionally renders content.\n",
      "decl": "type IfNode struct {\n\tCond any // *bool\n\tThen any\n}"
    },
    {
      "name": "InputC",
      "doc": "InputC is a text input with internal state management.\n",
      "decl": "type InputC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Input",
          "doc": "Input creates a text input with internal state.\nOptionally pass a *string to bind the input value to a variable.\n",
          "signature": "func Input(bind ...*string) *InputC",
          "examples": [
            {
              "doc": "Text input.\nA managed text input with placeholder text shown when empty.\n",
              "code": "Input().Placeholder(\"Type here...\")"
            },
            {
              "name": "mask",
              "doc": "Password input.\nMask hides input characters for sensitive fields.\n",
              "code": "Input().Placeholder(\"Password\").Mask('*')"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Bind",
          "doc": "Bind routes unmatched key input to this text field.\n",
          "signature": "func (i *InputC) Bind() *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Clear",
          "doc": "Clear resets the input.\n",
          "signature": "func (i *InputC) Clear()",
          "recv": "*InputC"
        },
        {
          "name": "Err",
          "doc": "Err returns the current validation error message, or empty string if valid.\n",
          "signature": "func (i *InputC) Err() string",
          "recv": "*InputC"
        },
        {
          "name": "Focused",
          "doc": "Focused returns whether this input currently has focus.\n",
          "signature": "func (i *InputC) Focused() bool",
          "recv": "*InputC"
        },
        {
          "name": "ManagedBy",
          "doc": "ManagedBy registers this input with a FocusManager.\nThis enables automatic focus cycling and keystroke routing.\n",
          "signature": "func (i *InputC) ManagedBy(fm *FocusManager) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (i *InputC) Margin(all int16) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (i *InputC) MarginTRBL(t, r, b, l int16) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (i *InputC) MarginVH(v, h int16) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Mask",
          "doc": "Mask sets a password mask character.\n",
          "signature": "func (i *InputC) Mask(m rune) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Placeholder",
          "doc": "Placeholder sets the placeholder text.\n",
          "signature": "func (i *InputC) Placeholder(p string) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (i *InputC) Ref(f func(*InputC)) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "SetValue",
          "doc": "SetValue sets the text value.\n",
          "signature": "func (i *InputC) SetValue(v string)",
          "recv": "*InputC"
        },
        {
          "name": "State",
          "doc": "State returns a pointer to the internal input state (for TextInput compatibility).\n",
          "signature": "func (i *InputC) State() *InputState",
          "recv": "*InputC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (i *InputC) Style(s Style) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Validate",
          "doc": "Validate sets a validation function and when it runs.\nIf when is omitted, defaults to VOnBlur|VOnSubmit.\n",
          "signature": "func (i *InputC) Validate(fn StringValidator, when ...ValidateOn) *InputC",
          "recv": "*InputC"
        },
        {
          "name": "Value",
          "doc": "Value returns the current text value.\n",
          "signature": "func (i *InputC) Value() string",
          "recv": "*InputC"
        },
        {
          "name": "Width",
          "doc": "Width sets the input width.\n",
          "signature": "func (i *InputC) Width(w int16) *InputC",
          "recv": "*InputC"
        }
      ]
    },
    {
      "name": "InputState",
      "doc": "InputState bundles the state for a text input field.\nUse with TextInput.Field for cleaner multi-field forms.\n",
      "decl": "type InputState struct {\n\tValue  string\n\tCursor int\n}",
      "methods": [
        {
          "name": "Clear",
          "doc": "Clear resets the field value and cursor.\n",
          "signature": "func (f *InputState) Clear()",
          "recv": "*InputState"
        }
      ]
    },
    {
      "name": "JumpC",
      "doc": "",
      "decl": "type JumpC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Jump",
          "doc": "Jump wraps a child component as a jump target.\n",
          "signature": "func Jump(child any, onSelect func()) JumpC"
        }
      ],
      "methods": [
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (j JumpC) Margin(all int16) JumpC",
          "recv": "JumpC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (j JumpC) MarginTRBL(a, b, c, d int16) JumpC",
          "recv": "JumpC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (j JumpC) MarginVH(v, h int16) JumpC",
          "recv": "JumpC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (j JumpC) Style(s Style) JumpC",
          "recv": "JumpC"
        }
      ],
      "examples": [
        {
          "doc": "Jump target.\nWrap any component as a jump target. When jump mode is active, labelled hints appear over each target.\n",
          "code": "selected := \"none\"\nJump(Text(\"clickable item\"), func() {\n\tselected = \"clicked\"\n\t_ = selected\n})"
        },
        {
          "name": "app",
          "doc": "App-level jump mode.\nPress the jump key to enter jump mode, then type a target label to select it.\n",
          "code": "app, _ := NewApp()\n\nitems := []string{\"Save\", \"Load\", \"Quit\"}\napp.SetView(VBox(\n\tJump(Text(\u0026items[0]), func() {}),\n\tJump(Text(\u0026items[1]), func() {}),\n\tJump(Text(\u0026items[2]), func() { app.Stop() }),\n))\n\napp.JumpKey(\"f\")\napp.Run()"
        }
      ]
    },
    {
      "name": "JumpMode",
      "doc": "JumpMode holds the state for jump label mode.\n",
      "decl": "type JumpMode struct {\n\tActive  bool\n\tTargets []JumpTarget\n\tInput   string // Accumulated input for multi-char labels\n}",
      "methods": [
        {
          "name": "AddTarget",
          "doc": "AddTarget adds a jump target during render.\n",
          "signature": "func (jm *JumpMode) AddTarget(x, y int16, onSelect func(), style Style)",
          "recv": "*JumpMode"
        },
        {
          "name": "AssignLabels",
          "doc": "AssignLabels assigns labels to all collected targets.\n",
          "signature": "func (jm *JumpMode) AssignLabels()",
          "recv": "*JumpMode"
        },
        {
          "name": "ClearJumpTargets",
          "doc": "ClearJumpTargets resets the jump targets slice for reuse.\n",
          "signature": "func (jm *JumpMode) ClearJumpTargets()",
          "recv": "*JumpMode"
        },
        {
          "name": "FindTarget",
          "doc": "FindTarget finds a target by its label.\n",
          "signature": "func (jm *JumpMode) FindTarget(label string) *JumpTarget",
          "recv": "*JumpMode"
        },
        {
          "name": "HasPartialMatch",
          "doc": "HasPartialMatch checks if any target label starts with the given prefix.\n",
          "signature": "func (jm *JumpMode) HasPartialMatch(prefix string) bool",
          "recv": "*JumpMode"
        }
      ]
    },
    {
      "name": "JumpNode",
      "doc": "JumpNode wraps a component to make it a jump target.\nWhen jump mode is active, a label is displayed at this component's position.\nWhen the user types the label, OnSelect is called.\n",
      "decl": "type JumpNode struct {\n\tChild    any    // The wrapped component\n\tOnSelect func() // Called when this target is selected\n\tStyle    Style  // Optional: per-target label style override\n}"
    },
    {
      "name": "JumpStyle",
      "doc": "JumpStyle configures the appearance of jump labels.\n",
      "decl": "type JumpStyle struct {\n\tLabelStyle Style // Style for the label character(s)\n}"
    },
    {
      "name": "JumpTarget",
      "doc": "JumpTarget represents a single jumpable location.\n",
      "decl": "type JumpTarget struct {\n\tX, Y     int16\n\tLabel    string\n\tOnSelect func()\n\tStyle    Style // Per-target override (zero value = use default)\n}"
    },
    {
      "name": "Layer",
      "doc": "Layer is a pre-rendered buffer with scroll management.\nContent is rendered once (expensive), then blitted to screen each frame (cheap).\n\nIf Render is set, the framework automatically calls it before blitting when\nthe viewport dimensions change. This ensures content is always rendered at\nthe correct size without manual timing coordination.\n",
      "decl": "type Layer struct {\n\n\t// Render populates the layer buffer. Called automatically by the framework\n\t// before blitting when viewport dimensions change. The layer ensures its\n\t// buffer exists and is sized appropriately before calling this.\n\t//\n\t// Width changes always trigger a re-render (text wrapping changes).\n\t// Height changes trigger a re-render if content height depends on viewport.\n\tRender func()\n\n\t// AlwaysRender causes Render to fire every frame, not just on width changes.\n\t// Used by components that track external pointer mutations (e.g. TextViewC).\n\tAlwaysRender bool\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewLayer",
          "doc": "NewLayer creates a new empty layer.\n",
          "signature": "func NewLayer() *Layer"
        }
      ],
      "methods": [
        {
          "name": "Buffer",
          "doc": "Buffer returns the underlying buffer (for direct manipulation if needed).\n",
          "signature": "func (l *Layer) Buffer() *Buffer",
          "recv": "*Layer"
        },
        {
          "name": "Clear",
          "doc": "Clear clears the entire layer buffer.\n",
          "signature": "func (l *Layer) Clear()",
          "recv": "*Layer"
        },
        {
          "name": "ContentHeight",
          "doc": "ContentHeight returns the total content height.\n",
          "signature": "func (l *Layer) ContentHeight() int",
          "recv": "*Layer"
        },
        {
          "name": "Cursor",
          "doc": "Cursor returns the full cursor state.\n",
          "signature": "func (l *Layer) Cursor() Cursor",
          "recv": "*Layer"
        },
        {
          "name": "EnsureSize",
          "doc": "EnsureSize ensures the buffer is at least the given size.\nIf the buffer needs to grow, existing content is preserved.\n",
          "signature": "func (l *Layer) EnsureSize(width, height int)",
          "recv": "*Layer"
        },
        {
          "name": "HalfPageDown",
          "doc": "HalfPageDown scrolls down by half a viewport.\n",
          "signature": "func (l *Layer) HalfPageDown()",
          "recv": "*Layer"
        },
        {
          "name": "HalfPageUp",
          "doc": "HalfPageUp scrolls up by half a viewport.\n",
          "signature": "func (l *Layer) HalfPageUp()",
          "recv": "*Layer"
        },
        {
          "name": "HideCursor",
          "doc": "HideCursor hides the cursor.\n",
          "signature": "func (l *Layer) HideCursor()",
          "recv": "*Layer"
        },
        {
          "name": "MaxScroll",
          "doc": "MaxScroll returns the maximum scroll position.\n",
          "signature": "func (l *Layer) MaxScroll() int",
          "recv": "*Layer"
        },
        {
          "name": "NeedsRender",
          "doc": "NeedsRender returns true if the layer needs to re-render before blitting.\nWidth changes always require re-render (text wrapping). Height changes\nrequire re-render if this is the first render or content is height-dependent.\n",
          "signature": "func (l *Layer) NeedsRender() bool",
          "recv": "*Layer"
        },
        {
          "name": "PageDown",
          "doc": "PageDown scrolls down by one viewport height.\n",
          "signature": "func (l *Layer) PageDown()",
          "recv": "*Layer"
        },
        {
          "name": "PageUp",
          "doc": "PageUp scrolls up by one viewport height.\n",
          "signature": "func (l *Layer) PageUp()",
          "recv": "*Layer"
        },
        {
          "name": "ScreenCursor",
          "doc": "ScreenCursor returns the cursor position in screen coordinates.\nThis accounts for the layer's position on screen and scroll offset.\nReturns the cursor and whether it's visible and within the viewport.\n",
          "signature": "func (l *Layer) ScreenCursor() (x, y int, visible bool)",
          "recv": "*Layer"
        },
        {
          "name": "ScrollDown",
          "doc": "ScrollDown scrolls down by n lines.\n",
          "signature": "func (l *Layer) ScrollDown(n int)",
          "recv": "*Layer"
        },
        {
          "name": "ScrollTo",
          "doc": "ScrollTo sets the scroll position, clamping to valid range.\n",
          "signature": "func (l *Layer) ScrollTo(y int)",
          "recv": "*Layer"
        },
        {
          "name": "ScrollToEnd",
          "doc": "ScrollToEnd scrolls to the bottom.\n",
          "signature": "func (l *Layer) ScrollToEnd()",
          "recv": "*Layer"
        },
        {
          "name": "ScrollToTop",
          "doc": "ScrollToTop scrolls to the top.\n",
          "signature": "func (l *Layer) ScrollToTop()",
          "recv": "*Layer"
        },
        {
          "name": "ScrollUp",
          "doc": "ScrollUp scrolls up by n lines.\n",
          "signature": "func (l *Layer) ScrollUp(n int)",
          "recv": "*Layer"
        },
        {
          "name": "ScrollY",
          "doc": "ScrollY returns the current scroll position.\n",
          "signature": "func (l *Layer) ScrollY() int",
          "recv": "*Layer"
        },
        {
          "name": "SetBuffer",
          "doc": "SetBuffer directly sets the layer's buffer.\nUse this if you're managing the buffer yourself.\n",
          "signature": "func (l *Layer) SetBuffer(buf *Buffer)",
          "recv": "*Layer"
        },
        {
          "name": "SetContent",
          "doc": "SetContent renders a template to the layer's internal buffer.\nCall this when content changes (e.g., page navigation).\n",
          "signature": "func (l *Layer) SetContent(tmpl *Template, width, height int)",
          "recv": "*Layer"
        },
        {
          "name": "SetCursor",
          "doc": "SetCursor sets the cursor position in buffer coordinates.\nThe framework translates this to screen coordinates when rendering.\n",
          "signature": "func (l *Layer) SetCursor(x, y int)",
          "recv": "*Layer"
        },
        {
          "name": "SetCursorStyle",
          "doc": "SetCursorStyle sets the cursor visual style.\n",
          "signature": "func (l *Layer) SetCursorStyle(style CursorShape)",
          "recv": "*Layer"
        },
        {
          "name": "SetLine",
          "doc": "SetLine updates a single line in the layer buffer with styled spans.\nThis is the efficient path for partial updates (e.g., cursor moved).\nClears the line first to prevent ghost content from shorter lines.\n",
          "signature": "func (l *Layer) SetLine(y int, spans []Span)",
          "recv": "*Layer"
        },
        {
          "name": "SetLineAt",
          "doc": "SetLineAt updates a line with spans at a given x offset.\nClears the entire line with clearStyle first, then writes spans at offset x.\nUse this to avoid creating padding spans for margins.\n",
          "signature": "func (l *Layer) SetLineAt(y, x int, spans []Span, clearStyle Style)",
          "recv": "*Layer"
        },
        {
          "name": "SetLineString",
          "doc": "SetLineString updates a single line with a plain string and style.\nClears the line first to prevent ghost content from shorter lines.\n",
          "signature": "func (l *Layer) SetLineString(y int, s string, style Style)",
          "recv": "*Layer"
        },
        {
          "name": "SetViewport",
          "doc": "SetViewport sets the viewport dimensions for the layer.\nCalled internally by the framework during layout.\n",
          "signature": "func (l *Layer) SetViewport(width, height int)",
          "recv": "*Layer"
        },
        {
          "name": "ShowCursor",
          "doc": "ShowCursor makes the cursor visible.\n",
          "signature": "func (l *Layer) ShowCursor()",
          "recv": "*Layer"
        },
        {
          "name": "ViewportHeight",
          "doc": "ViewportHeight returns the visible viewport height.\n",
          "signature": "func (l *Layer) ViewportHeight() int",
          "recv": "*Layer"
        },
        {
          "name": "ViewportWidth",
          "doc": "ViewportWidth returns the visible viewport width.\n",
          "signature": "func (l *Layer) ViewportWidth() int",
          "recv": "*Layer"
        }
      ],
      "examples": [
        {
          "doc": "Manual content.\nWrite lines directly to a Layer for manual content control. The Render callback fires when the viewport resizes.\n",
          "code": "layer := NewLayer()\nlayer.Render = func() {\n\tlayer.SetLineString(0, \"redrawn\", DefaultStyle())\n}\nlayer.SetLineString(0, \"first line\", DefaultStyle())\nlayer.SetLineString(1, \"second line\", DefaultStyle().Bold())\n\nLayerView(layer).Grow(1)"
        }
      ]
    },
    {
      "name": "LayerViewC",
      "doc": "",
      "decl": "type LayerViewC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "LayerView",
          "doc": "LayerView displays a pre-rendered layer with scrolling support.\n",
          "signature": "func LayerView(layer *Layer) LayerViewC"
        }
      ],
      "methods": [
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (l LayerViewC) Grow(g float32) LayerViewC",
          "recv": "LayerViewC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (l LayerViewC) Margin(all int16) LayerViewC",
          "recv": "LayerViewC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (l LayerViewC) MarginTRBL(a, b, c, d int16) LayerViewC",
          "recv": "LayerViewC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (l LayerViewC) MarginVH(v, h int16) LayerViewC",
          "recv": "LayerViewC"
        },
        {
          "name": "ViewHeight",
          "doc": "Height sets a fixed height.\n",
          "signature": "func (l LayerViewC) ViewHeight(h int16) LayerViewC",
          "recv": "LayerViewC"
        },
        {
          "name": "ViewWidth",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (l LayerViewC) ViewWidth(w int16) LayerViewC",
          "recv": "LayerViewC"
        }
      ],
      "examples": [
        {
          "doc": "Scrollable canvas.\nLayerView displays a Layer — a virtual canvas that can be larger than the viewport.\n",
          "code": "layer := NewLayer()\n\nLayerView(layer).Grow(1)"
        }
      ]
    },
    {
      "name": "LayerViewNode",
      "doc": "LayerViewNode displays a scrollable layer.\nThe Layer is pre-rendered content that gets blitted to screen.\n",
      "decl": "type LayerViewNode struct {\n\tFlex\n\tLayer      *Layer // the pre-rendered layer\n\tViewHeight int16  // viewport height (0 = fill available, distinct from Flex.Height)\n\tViewWidth  int16  // viewport width (0 = fill available, distinct from Flex.Width)\n}",
      "methods": [
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor for this layer.\n",
          "signature": "func (l LayerViewNode) Grow(factor float32) LayerViewNode",
          "recv": "LayerViewNode"
        }
      ]
    },
    {
      "name": "LayoutFunc",
      "doc": "LayoutFunc positions children given their sizes and available space.\n",
      "decl": "type LayoutFunc func(children []ChildSize, availW, availH int) []Rect"
    },
    {
      "name": "LeaderC",
      "doc": "",
      "decl": "type LeaderC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Leader",
          "doc": "Leader creates a label.....value display with fill characters.\n",
          "signature": "func Leader(label, value any) LeaderC",
          "examples": [
            {
              "doc": "Leader line.\nLabel on the left, value on the right, dots filling the gap. Both sides read from pointers each frame.\n",
              "code": "label := \"Total\"\nvalue := \"$42.00\"\n\nLeader(\u0026label, \u0026value)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (l LeaderC) BG(c Color) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (l LeaderC) Bold() LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (l LeaderC) FG(c Color) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "Fill",
          "doc": "Fill sets the fill character.\n",
          "signature": "func (l LeaderC) Fill(r rune) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (l LeaderC) Margin(all int16) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (l LeaderC) MarginTRBL(a, b, c, d int16) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (l LeaderC) MarginVH(v, h int16) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (l LeaderC) Style(s Style) LeaderC",
          "recv": "LeaderC"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (l LeaderC) Width(w int16) LeaderC",
          "recv": "LeaderC"
        }
      ]
    },
    {
      "name": "LeaderNode",
      "doc": "LeaderNode displays \"Label.....Value\" with dots filling the space.\nSupports pointer bindings for dynamic updates.\n",
      "decl": "type LeaderNode struct {\n\tLabel any   // string or *string\n\tValue any   // string or *string\n\tWidth int16 // total width (0 = fill available from parent)\n\tFill  rune  // fill character (0 = '.')\n\tStyle Style // styling (use Attr for bold, dim, etc.)\n}"
    },
    {
      "name": "ListC",
      "doc": "",
      "decl": "type ListC[T any] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "List",
          "doc": "List creates a selectable list with internal selection management.\nUse .Render() to provide custom item rendering.\n",
          "signature": "func List[T any](items *[]T) *ListC[T]",
          "examples": [
            {
              "doc": "Navigable list.\nA list over a pointer to a slice. The Render callback receives a pointer to each item for in-place updates.\n",
              "code": "items := []string{\"Alpha\", \"Beta\", \"Gamma\"}\n\nList(\u0026items).Render(func(item *string) any {\n\treturn Text(item)\n}).BindNav(\"j\", \"k\")"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BindDelete",
          "doc": "BindDelete registers a key binding to delete the selected item.\n",
          "signature": "func (l *ListC[T]) BindDelete(key string) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "BindFirstLast",
          "doc": "BindFirstLast registers key bindings for jumping to first/last item.\n",
          "signature": "func (l *ListC[T]) BindFirstLast(first, last string) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for moving selection down and up.\n",
          "signature": "func (l *ListC[T]) BindNav(down, up string) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "BindPageNav",
          "doc": "BindPageNav registers key bindings for page-sized movement.\n",
          "signature": "func (l *ListC[T]) BindPageNav(pageDown, pageUp string) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "BindVimNav",
          "doc": "BindVimNav wires the standard vim-style navigation keys:\nj/k for line movement, Ctrl-d/Ctrl-u for page, g/G for first/last.\n",
          "signature": "func (l *ListC[T]) BindVimNav() *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "ClampSelection",
          "doc": "ClampSelection ensures the selection index is within bounds.\n",
          "signature": "func (l *ListC[T]) ClampSelection()",
          "recv": "*ListC[T]"
        },
        {
          "name": "Delete",
          "doc": "Delete removes the currently selected item.\n",
          "signature": "func (l *ListC[T]) Delete()",
          "recv": "*ListC[T]"
        },
        {
          "name": "Down",
          "doc": "Down moves selection down by one.\n",
          "signature": "func (l *ListC[T]) Down(m any)",
          "recv": "*ListC[T]"
        },
        {
          "name": "First",
          "doc": "First moves selection to first item.\n",
          "signature": "func (l *ListC[T]) First(m any)",
          "recv": "*ListC[T]"
        },
        {
          "name": "Handle",
          "doc": "Handle registers a key binding that passes the currently selected item\nto the callback. If nothing is selected, the callback is not called.\n",
          "signature": "func (l *ListC[T]) Handle(key string, fn func(*T)) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Index",
          "doc": "Index returns the current selection index.\n",
          "signature": "func (l *ListC[T]) Index() int",
          "recv": "*ListC[T]"
        },
        {
          "name": "Last",
          "doc": "Last moves selection to last item.\n",
          "signature": "func (l *ListC[T]) Last(m any)",
          "recv": "*ListC[T]"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (l *ListC[T]) Margin(all int16) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (l *ListC[T]) MarginTRBL(t, r, b, li int16) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (l *ListC[T]) MarginVH(v, h int16) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Marker",
          "doc": "Marker sets the selection marker (default \"\u003e \").\n",
          "signature": "func (l *ListC[T]) Marker(m string) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "MarkerStyle",
          "doc": "MarkerStyle sets the style for the marker text.\n",
          "signature": "func (l *ListC[T]) MarkerStyle(s Style) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "MaxVisible",
          "doc": "MaxVisible sets the maximum visible items (0 = show all).\n",
          "signature": "func (l *ListC[T]) MaxVisible(n int) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "OnSelect",
          "doc": "OnSelect registers a callback that fires when the selection changes.\n",
          "signature": "func (l *ListC[T]) OnSelect(fn func(*T)) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "PageDown",
          "doc": "PageDown moves selection down by page size.\n",
          "signature": "func (l *ListC[T]) PageDown(m any)",
          "recv": "*ListC[T]"
        },
        {
          "name": "PageUp",
          "doc": "PageUp moves selection up by page size.\n",
          "signature": "func (l *ListC[T]) PageUp(m any)",
          "recv": "*ListC[T]"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (l *ListC[T]) Ref(f func(*ListC[T])) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Render",
          "doc": "Render sets a custom render function for each item.\n",
          "signature": "func (l *ListC[T]) Render(fn func(*T) any) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Selected",
          "doc": "Selected returns a pointer to the currently selected item, or nil if empty.\n",
          "signature": "func (l *ListC[T]) Selected() *T",
          "recv": "*ListC[T]"
        },
        {
          "name": "SelectedStyle",
          "doc": "SelectedStyle sets the style for the selected row.\n",
          "signature": "func (l *ListC[T]) SelectedStyle(s Style) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Selection",
          "doc": "Selection binds the selection index to an external pointer.\n",
          "signature": "func (l *ListC[T]) Selection(sel *int) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "SetIndex",
          "doc": "SetIndex sets the selection index directly.\n",
          "signature": "func (l *ListC[T]) SetIndex(i int)",
          "recv": "*ListC[T]"
        },
        {
          "name": "Style",
          "doc": "Style sets the default style for non-selected rows.\n",
          "signature": "func (l *ListC[T]) Style(s Style) *ListC[T]",
          "recv": "*ListC[T]"
        },
        {
          "name": "Up",
          "doc": "Up moves selection up by one.\n",
          "signature": "func (l *ListC[T]) Up(m any)",
          "recv": "*ListC[T]"
        }
      ]
    },
    {
      "name": "LogC",
      "doc": "LogC displays a scrollable log that reads from an io.Reader.\nLines are buffered internally with optional max line limit (ring buffer).\nScrolling is handled automatically via the underlying Layer.\n",
      "decl": "type LogC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Log",
          "doc": "Log creates a log that reads lines from the given reader.\nThe reader is consumed in a background goroutine that exits on EOF/error.\n",
          "signature": "func Log(r io.Reader) *LogC"
        }
      ],
      "methods": [
        {
          "name": "AutoScroll",
          "doc": "AutoScroll controls whether the view automatically scrolls to show new lines.\nDefault is true. When the user scrolls up, auto-scroll pauses until they\nreturn to the bottom.\n",
          "signature": "func (lv *LogC) AutoScroll(enabled bool) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "BindFirstLast",
          "doc": "BindFirstLast registers key bindings for jumping to top/bottom.\n",
          "signature": "func (lv *LogC) BindFirstLast(first, last string) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for scrolling down/up by one line.\n",
          "signature": "func (lv *LogC) BindNav(down, up string) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "BindPageNav",
          "doc": "BindPageNav registers key bindings for half-page scrolling.\n",
          "signature": "func (lv *LogC) BindPageNav(down, up string) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "BindVimNav",
          "doc": "BindVimNav wires standard vim-style scroll keys:\nj/k: line, Ctrl-d/u: half-page, g/G: top/bottom\n",
          "signature": "func (lv *LogC) BindVimNav() *LogC",
          "recv": "*LogC"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (lv *LogC) Grow(g float32) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "Layer",
          "doc": "Layer returns the underlying layer for manual scroll control.\nUse this to bind key handlers for scrolling (j/k, Page Up/Down, etc.).\n",
          "signature": "func (lv *LogC) Layer() *Layer",
          "recv": "*LogC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets equal margin on all sides.\n",
          "signature": "func (lv *LogC) Margin(all int16) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets top, right, bottom, left margins individually.\n",
          "signature": "func (lv *LogC) MarginTRBL(t, r, b, l int16) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margins.\n",
          "signature": "func (lv *LogC) MarginVH(v, h int16) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "MaxLines",
          "doc": "MaxLines sets the maximum number of lines to keep in the buffer.\nOldest lines are dropped when the limit is exceeded. Default is 1000.\n",
          "signature": "func (lv *LogC) MaxLines(n int) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "NewLines",
          "doc": "NewLines returns the number of new lines that have arrived while not following.\nUse this to display an indicator like \"42 new lines ↓\".\n",
          "signature": "func (lv *LogC) NewLines() int",
          "recv": "*LogC"
        },
        {
          "name": "OnUpdate",
          "doc": "OnUpdate sets a callback to be called when new lines arrive.\nUse this with app.RequestRender to trigger redraws:\n\n\tLog(reader).OnUpdate(app.RequestRender)\n",
          "signature": "func (lv *LogC) OnUpdate(f func()) *LogC",
          "recv": "*LogC"
        },
        {
          "name": "Ref",
          "doc": "Ref calls f with this LogC and returns it for chaining.\n",
          "signature": "func (lv *LogC) Ref(f func(*LogC)) *LogC",
          "recv": "*LogC"
        }
      ],
      "examples": [
        {
          "doc": "Streaming log.\nStream lines from any io.Reader into a scrollable log view. AutoScroll keeps the view pinned to the bottom.\n",
          "code": "r := strings.NewReader(\"line 1\\nline 2\\nline 3\\n\")\n\nLog(r).MaxLines(1000).AutoScroll(true).BindVimNav()"
        },
        {
          "name": "fromStdin",
          "doc": "Stdin pipe.\nPipe stdout from a subprocess or os.Stdin directly into a log view. The reader is consumed in a background goroutine.\n",
          "code": "Log(os.Stdin).MaxLines(5000).Grow(1)"
        }
      ]
    },
    {
      "name": "Op",
      "doc": "Op represents a single instruction.\n",
      "decl": "type Op struct {\n\tKind   OpKind\n\tDepth  int8  // tree depth (root children = 0)\n\tParent int16 // parent op index, -1 for root children\n\n\t// Value access - one used based on Kind\n\tStaticStr string\n\tStrPtr    *string\n\tStrOff    uintptr // offset from element base (for ForEach)\n\tTextStyle Style   // style for text rendering\n\n\tStaticInt int\n\tIntPtr    *int\n\tIntOff    uintptr\n\n\t// Layout hints\n\tWidth        int16   // explicit width\n\tHeight       int16   // explicit height\n\tPercentWidth float32 // 0.0-1.0\n\tFlexGrow     float32 // share of remaining space\n\tGap          int8    // gap between children\n\tContentSized bool    // has fixed-width children (don't implicit flex)\n\tFitContent   bool    // size to content instead of filling available space\n\n\t// Container\n\tIsRow        bool        // true=HBox, false=VBox\n\tBorder       BorderStyle // border style\n\tBorderFG     *Color      // border foreground color\n\tBorderBG     *Color      // border background color\n\tTitle        string      // border title\n\tChildStart   int16       // first child op index\n\tChildEnd     int16       // last child op index (exclusive)\n\tCascadeStyle *Style      // style inherited by children (pointer for dynamic themes)\n\tFill         Color       // container fill color (fills entire area)\n\tMargin       [4]int16    // outer margin: top, right, bottom, left\n\n\t// Control flow\n\tCondPtr  *bool         // for If (simple bool pointer)\n\tCondNode conditionNode // for If (builder-style conditions)\n\tThenTmpl *Template     // for If\n\tElseTmpl *Template     // for If/Else\n\tIterTmpl *Template     // for ForEach\n\tSlicePtr unsafe.Pointer\n\tElemSize uintptr\n\n\t// Switch\n\tSwitchNode  switchNodeInterface\n\tSwitchCases []*Template\n\tSwitchDef   *Template\n\n\t// Custom renderer\n\tCustomRenderer Renderer\n\n\t// Custom layout\n\tCustomLayout LayoutFunc\n\n\t// Layer\n\tLayerPtr    *Layer // pointer to Layer\n\tLayerWidth  int16  // viewport width (0 = fill available)\n\tLayerHeight int16  // viewport height (0 = fill available)\n\n\t// RichText\n\tStaticSpans []Span  // for static spans\n\tSpansPtr    *[]Span // for pointer to spans\n\tSpansOff    uintptr // for ForEach offset\n\n\t// SelectionList\n\tSelectionListPtr *SelectionList // pointer to the list for len/offset updates\n\tSelectedPtr      *int           // pointer to selected index\n\tMarker           string         // selection marker (e.g., \"\u003e \")\n\tMarkerWidth      int16          // cached rune count of marker\n\tMarkerSpaces     string         // pre-computed spaces matching marker width\n\n\t// Leader\n\tLeaderLabel    string   // static label\n\tLeaderValue    string   // static value (OpLeader)\n\tLeaderValuePtr *string  // pointer value (OpLeaderPtr)\n\tLeaderIntPtr   *int     // pointer to int (OpLeaderIntPtr)\n\tLeaderFloatPtr *float64 // pointer to float64 (OpLeaderFloatPtr)\n\tLeaderFill     rune     // fill character (default '.')\n\tLeaderStyle    Style    // styling\n\n\t// Table\n\tTableColumns     []TableColumn // column definitions\n\tTableRowsPtr     *[][]string   // pointer to row data\n\tTableShowHeader  bool          // show header row\n\tTableHeaderStyle Style         // style for header\n\tTableRowStyle    Style         // style for rows\n\tTableAltStyle    Style         // alternating row style\n\n\t// AutoTable (reactive pointer-backed)\n\tAutoTableSlicePtr any                 // *[]T -- pointer to slice of structs\n\tAutoTableFields   []int               // field indices into the struct\n\tAutoTableHeaders  []string            // header labels\n\tAutoTableHdrStyle Style               // header style\n\tAutoTableRowStyle Style               // row style\n\tAutoTableAltStyle *Style              // alternating row style\n\tAutoTableGap      int8                // gap between columns\n\tAutoTableFill     Color               // row fill for alt rows\n\tAutoTableColCfgs  []*ColumnConfig     // per-column config (parallel to Fields, nil = no config)\n\tAutoTableSort     *autoTableSortState // nil unless sorting enabled\n\tAutoTableScroll   *autoTableScroll    // nil unless scrolling enabled\n\n\t// Sparkline\n\tSparkValues    []float64  // static values\n\tSparkValuesPtr *[]float64 // pointer values\n\tSparkMin       float64    // min value (0 = auto)\n\tSparkMax       float64    // max value (0 = auto)\n\tSparkStyle     Style      // styling\n\n\t// HRule/VRule\n\tRuleChar  rune  // line character\n\tRuleStyle Style // styling\n\n\t// Spinner\n\tSpinnerFramePtr *int     // pointer to frame index\n\tSpinnerFrames   []string // animation frames\n\tSpinnerStyle    Style    // styling\n\n\t// Scrollbar\n\tScrollContentSize int   // total content size\n\tScrollViewSize    int   // visible viewport size\n\tScrollPosPtr      *int  // pointer to scroll position\n\tScrollHorizontal  bool  // true for horizontal scrollbar\n\tScrollTrackChar   rune  // track character\n\tScrollThumbChar   rune  // thumb character\n\tScrollTrackStyle  Style // track styling\n\tScrollThumbStyle  Style // thumb styling\n\n\t// Tabs\n\tTabsLabels        []string  // tab labels\n\tTabsSelectedPtr   *int      // pointer to selected tab index\n\tTabsStyleType     TabsStyle // visual style\n\tTabsGap           int       // gap between tabs\n\tTabsActiveStyle   Style     // style for active tab\n\tTabsInactiveStyle Style     // style for inactive tabs\n\n\t// TreeView\n\tTreeRoot          *TreeNode // root node\n\tTreeShowRoot      bool      // whether to display root\n\tTreeIndent        int       // indentation per level\n\tTreeShowLines     bool      // show connecting lines\n\tTreeExpandedChar  rune      // expanded indicator\n\tTreeCollapsedChar rune      // collapsed indicator\n\tTreeLeafChar      rune      // leaf indicator\n\tTreeStyle         Style     // styling\n\n\t// Jump (jump target wrapper) - just marks a position, child is inline\n\tJumpOnSelect func() // callback when target is selected\n\tJumpStyle    Style  // label style override (zero = use app default)\n\n\t// TextInput\n\tTextInputFieldPtr       *InputState // Field-based API (bundles Value+Cursor)\n\tTextInputFocusGroupPtr  *FocusGroup // shared focus tracker\n\tTextInputFocusIndex     int         // this field's index in focus group\n\tTextInputValuePtr       *string     // bound text value (legacy)\n\tTextInputCursorPtr      *int        // bound cursor position (legacy)\n\tTextInputFocusedPtr     *bool       // show cursor only when true (legacy)\n\tTextInputPlaceholder    string      // placeholder text\n\tTextInputMask           rune        // password mask (0 = none)\n\tTextInputStyle          Style       // text style\n\tTextInputPlaceholderSty Style       // placeholder style\n\tTextInputCursorStyle    Style       // cursor style\n\n\t// Overlay\n\tOverlayCentered    bool      // center on screen\n\tOverlayX, OverlayY int16     // explicit position\n\tOverlayBackdrop    bool      // draw backdrop\n\tOverlayBackdropFG  Color     // backdrop color\n\tOverlayBG          Color     // background fill for overlay content area\n\tOverlayChildTmpl   *Template // compiled child content\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "OpKind",
      "doc": "",
      "decl": "type OpKind uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "OpText",
            "OpTextPtr",
            "OpTextOff",
            "OpProgress",
            "OpProgressPtr",
            "OpProgressOff",
            "OpContainer",
            "OpIf",
            "OpForEach",
            "OpSwitch",
            "OpCustom",
            "OpLayout",
            "OpLayer",
            "OpRichText",
            "OpRichTextPtr",
            "OpRichTextOff",
            "OpSelectionList",
            "OpLeader",
            "OpLeaderPtr",
            "OpLeaderIntPtr",
            "OpLeaderFloatPtr",
            "OpTable",
            "OpAutoTable",
            "OpSparkline",
            "OpSparklinePtr",
            "OpHRule",
            "OpVRule",
            "OpSpacer",
            "OpSpinner",
            "OpScrollbar",
            "OpTabs",
            "OpTreeView",
            "OpJump",
            "OpTextInput",
            "OpOverlay"
          ],
          "decl": "const (\n\tOpText OpKind = iota\n\tOpTextPtr\n\tOpTextOff\n\n\tOpProgress\n\tOpProgressPtr\n\tOpProgressOff\n\n\tOpContainer // VBox or HBox (determined by IsRow)\n\n\tOpIf\n\tOpForEach\n\tOpSwitch\n\n\tOpCustom // Custom renderer\n\tOpLayout // Custom layout\n\tOpLayer  // LayerView (scrollable off-screen buffer)\n\n\tOpRichText    // RichText with static spans\n\tOpRichTextPtr // RichText with pointer to spans\n\tOpRichTextOff // RichText with offset (ForEach)\n\n\tOpSelectionList // SelectionList with marker and windowing\n\n\tOpLeader         // Leader with static label and value\n\tOpLeaderPtr      // Leader with pointer value\n\tOpLeaderIntPtr   // Leader with int pointer value\n\tOpLeaderFloatPtr // Leader with float64 pointer value\n\n\tOpTable     // Table with columns and rows\n\tOpAutoTable // AutoTable with pointer to slice of structs (reactive)\n\n\tOpSparkline    // Sparkline with static values\n\tOpSparklinePtr // Sparkline with pointer values\n\n\tOpHRule     // Horizontal line\n\tOpVRule     // Vertical line\n\tOpSpacer    // Empty space\n\tOpSpinner   // Animated spinner\n\tOpScrollbar // Scroll indicator\n\tOpTabs      // Tab headers\n\tOpTreeView  // Hierarchical tree\n\tOpJump      // Jump target wrapper\n\tOpTextInput // Single-line text input\n\tOpOverlay   // Floating overlay/modal\n)"
        }
      ]
    },
    {
      "name": "OrdCondition",
      "doc": "OrdCondition extends Condition for ordered types (int, float, string).\n",
      "decl": "type OrdCondition[T cmp.Ordered] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "IfOrd",
          "doc": "IfOrd starts a conditional chain for ordered types (supports Gt, Lt, etc).\n",
          "signature": "func IfOrd[T cmp.Ordered](ptr *T) *OrdCondition[T]"
        }
      ],
      "methods": [
        {
          "name": "Eq",
          "doc": "Eq checks equality\n",
          "signature": "func (c *OrdCondition[T]) Eq(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        },
        {
          "name": "Gt",
          "doc": "Gt checks greater than: *ptr \u003e val\n",
          "signature": "func (c *OrdCondition[T]) Gt(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        },
        {
          "name": "Gte",
          "doc": "Gte checks greater than or equal: *ptr \u003e= val\n",
          "signature": "func (c *OrdCondition[T]) Gte(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        },
        {
          "name": "Lt",
          "doc": "Lt checks less than: *ptr \u003c val\n",
          "signature": "func (c *OrdCondition[T]) Lt(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        },
        {
          "name": "Lte",
          "doc": "Lte checks less than or equal: *ptr \u003c= val\n",
          "signature": "func (c *OrdCondition[T]) Lte(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        },
        {
          "name": "Ne",
          "doc": "Ne checks inequality\n",
          "signature": "func (c *OrdCondition[T]) Ne(val T) *OrdConditionEval[T]",
          "recv": "*OrdCondition[T]"
        }
      ],
      "examples": [
        {
          "doc": "Numeric comparison.\nIfOrd supports Gt, Lt, Gte, Lte for any ordered type (int, float64, string).\n",
          "code": "count := 5\nIfOrd(\u0026count).Gte(10).Then(Text(\"many\")).Else(Text(\"few\"))"
        }
      ]
    },
    {
      "name": "OrdConditionEval",
      "doc": "OrdConditionEval holds an ordered condition ready for Then/Else\n",
      "decl": "type OrdConditionEval[T cmp.Ordered] struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Else",
          "doc": "Else specifies what to render when false\n",
          "signature": "func (e *OrdConditionEval[T]) Else(node any) *OrdConditionEval[T]",
          "recv": "*OrdConditionEval[T]"
        },
        {
          "name": "Then",
          "doc": "Then specifies what to render when true\n",
          "signature": "func (e *OrdConditionEval[T]) Then(node any) *OrdConditionEval[T]",
          "recv": "*OrdConditionEval[T]"
        }
      ]
    },
    {
      "name": "OverlayC",
      "doc": "",
      "decl": "type OverlayC struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "OverlayFn",
      "doc": "",
      "decl": "type OverlayFn func(children ...any) OverlayC",
      "methods": [
        {
          "name": "At",
          "doc": "At positions the overlay at fixed coordinates.\n",
          "signature": "func (f OverlayFn) At(x, y int) OverlayFn",
          "recv": "OverlayFn"
        },
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (f OverlayFn) BG(c Color) OverlayFn",
          "recv": "OverlayFn"
        },
        {
          "name": "Backdrop",
          "doc": "Backdrop renders a backdrop behind the top-most layer that fills the parent.\n",
          "signature": "func (f OverlayFn) Backdrop() OverlayFn",
          "recv": "OverlayFn"
        },
        {
          "name": "BackdropFG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (f OverlayFn) BackdropFG(c Color) OverlayFn",
          "recv": "OverlayFn"
        },
        {
          "name": "Centered",
          "doc": "Centered centers the overlay content within the parent bounds.\n",
          "signature": "func (f OverlayFn) Centered() OverlayFn",
          "recv": "OverlayFn"
        },
        {
          "name": "Size",
          "doc": "Size sets a fixed width and height.\n",
          "signature": "func (f OverlayFn) Size(w, h int) OverlayFn",
          "recv": "OverlayFn"
        }
      ],
      "vars": [
        {
          "doc": "",
          "names": [
            "Overlay"
          ],
          "decl": "var Overlay OverlayFn = func(children ...any) OverlayC {\n\treturn OverlayC{children: children}\n}"
        }
      ],
      "examples": [
        {
          "doc": "Basic layering.\nLayer children on top of each other. The last child renders on top.\n",
          "code": "Overlay(\n\tText(\"base content\"),\n\tText(\"floating dialog\"),\n)"
        },
        {
          "name": "modal",
          "doc": "Modal dialog.\nCentered dialog with a dimmed backdrop. Size constrains the dialog; Backdrop dims everything behind it.\n",
          "code": "Overlay.Centered().Backdrop().BackdropFG(BrightBlack).Size(50, 15).BG(Black)(\n\tVBox.Grow(1)(\n\t\tText(\"main content\"),\n\t),\n\tVBox.Border(BorderRounded)(\n\t\tText(\"confirm delete?\"),\n\t\tHBox.Gap(2)(Text(\"[y]es\"), Text(\"[n]o\")),\n\t),\n)"
        }
      ]
    },
    {
      "name": "OverlayNode",
      "doc": "OverlayNode displays content floating above the main view.\nUse for modals, dialogs, and floating windows.\nControl visibility with glyph.If:\n\n\tglyph.If(\u0026showModal).Eq(true).Then(glyph.Overlay{Child: ...})\n",
      "decl": "type OverlayNode struct {\n\tCentered   bool  // true = center on screen (default behavior if X/Y not set)\n\tX, Y       int   // explicit position (used if Centered is false)\n\tWidth      int   // explicit width (0 = auto from content)\n\tHeight     int   // explicit height (0 = auto from content)\n\tBackdrop   bool  // draw dimmed backdrop behind overlay\n\tBackdropFG Color // backdrop dim color (default: BrightBlack)\n\tBG         Color // background color for overlay content area (fills before rendering child)\n\tChild      any   // overlay content\n}"
    },
    {
      "name": "ProgressC",
      "doc": "",
      "decl": "type ProgressC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Progress",
          "doc": "Progress creates a progress bar bound to a value (0-100).\n",
          "signature": "func Progress(value any) ProgressC",
          "examples": [
            {
              "doc": "Progress bar.\nBound to a float64 pointer (0.0–1.0). Width sets the bar length in cells.\n",
              "code": "var pct float64\n\nProgress(\u0026pct).Width(30).FG(Green)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (p ProgressC) BG(c Color) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (p ProgressC) Bold() ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (p ProgressC) FG(c Color) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (p ProgressC) Margin(all int16) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (p ProgressC) MarginTRBL(a, b, c, d int16) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (p ProgressC) MarginVH(v, h int16) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (p ProgressC) Style(s Style) ProgressC",
          "recv": "ProgressC"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (p ProgressC) Width(w int16) ProgressC",
          "recv": "ProgressC"
        }
      ]
    },
    {
      "name": "ProgressNode",
      "doc": "ProgressNode displays a progress bar.\n",
      "decl": "type ProgressNode struct {\n\tFlex\n\tValue    any   // int or *int (0-100)\n\tBarWidth int16 // width of the bar in characters (distinct from Flex.Width layout width)\n}"
    },
    {
      "name": "RadioC",
      "doc": "RadioC is a single-selection group bound to *int (selected index).\n",
      "decl": "type RadioC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Radio",
          "doc": "Radio creates a radio group with static options.\n",
          "signature": "func Radio(selected *int, options ...string) *RadioC",
          "examples": [
            {
              "doc": "Radio group.\nBound to an int pointer. The selected index updates when the user navigates and presses enter.\n",
              "code": "var selected int\n\nRadio(\u0026selected, \"Small\", \"Medium\", \"Large\").BindNav(\"j\", \"k\")"
            }
          ]
        },
        {
          "name": "RadioPtr",
          "doc": "RadioPtr creates a radio group with dynamic options.\n",
          "signature": "func RadioPtr(selected *int, options *[]string) *RadioC"
        }
      ],
      "methods": [
        {
          "name": "BindNav",
          "doc": "BindNav registers key bindings for cycling selection.\n",
          "signature": "func (r *RadioC) BindNav(next, prev string) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Focused",
          "doc": "Focused returns whether this radio group currently has focus.\n",
          "signature": "func (r *RadioC) Focused() bool",
          "recv": "*RadioC"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between children.\n",
          "signature": "func (r *RadioC) Gap(g int8) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Horizontal",
          "doc": "Horizontal renders the scrollbar horizontally instead of vertically.\n",
          "signature": "func (r *RadioC) Horizontal() *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Index",
          "doc": "Index returns the selected index.\n",
          "signature": "func (r *RadioC) Index() int",
          "recv": "*RadioC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (r *RadioC) Margin(all int16) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (r *RadioC) MarginTRBL(t, ri, b, l int16) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (r *RadioC) MarginVH(v, h int16) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Marks",
          "doc": "Marks sets the selected and unselected display characters.\n",
          "signature": "func (r *RadioC) Marks(selected, unselected string) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Next",
          "doc": "Next moves selection to next option.\n",
          "signature": "func (r *RadioC) Next()",
          "recv": "*RadioC"
        },
        {
          "name": "Prev",
          "doc": "Prev moves selection to previous option.\n",
          "signature": "func (r *RadioC) Prev()",
          "recv": "*RadioC"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (r *RadioC) Ref(f func(*RadioC)) *RadioC",
          "recv": "*RadioC"
        },
        {
          "name": "Selected",
          "doc": "Selected returns the currently selected option text.\n",
          "signature": "func (r *RadioC) Selected() string",
          "recv": "*RadioC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (r *RadioC) Style(s Style) *RadioC",
          "recv": "*RadioC"
        }
      ]
    },
    {
      "name": "Rect",
      "doc": "Rect represents a positioned rectangle.\n",
      "decl": "type Rect struct {\n\tX, Y, W, H int\n}"
    },
    {
      "name": "Region",
      "doc": "Region returns a view into a rectangular region of the buffer.\nThe returned Region shares the underlying cells with the parent buffer.\n",
      "decl": "type Region struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Clear",
          "doc": "Clear clears the region to empty cells.\n",
          "signature": "func (r *Region) Clear()",
          "recv": "*Region"
        },
        {
          "name": "DrawBorder",
          "doc": "DrawBorder draws a border around the entire region.\n",
          "signature": "func (r *Region) DrawBorder(border BorderStyle, style Style)",
          "recv": "*Region"
        },
        {
          "name": "Fill",
          "doc": "Fill fills the region with the given cell.\n",
          "signature": "func (r *Region) Fill(c Cell)",
          "recv": "*Region"
        },
        {
          "name": "Get",
          "doc": "Get returns the cell at the given region-relative coordinates.\n",
          "signature": "func (r *Region) Get(x, y int) Cell",
          "recv": "*Region"
        },
        {
          "name": "Height",
          "doc": "Height returns the region height.\n",
          "signature": "func (r *Region) Height() int",
          "recv": "*Region"
        },
        {
          "name": "InBounds",
          "doc": "InBounds returns true if the given coordinates are within the region.\n",
          "signature": "func (r *Region) InBounds(x, y int) bool",
          "recv": "*Region"
        },
        {
          "name": "Set",
          "doc": "Set sets the cell at the given region-relative coordinates.\n",
          "signature": "func (r *Region) Set(x, y int, c Cell)",
          "recv": "*Region"
        },
        {
          "name": "Size",
          "doc": "Size returns the region dimensions.\n",
          "signature": "func (r *Region) Size() (width, height int)",
          "recv": "*Region"
        },
        {
          "name": "Width",
          "doc": "Width returns the region width.\n",
          "signature": "func (r *Region) Width() int",
          "recv": "*Region"
        },
        {
          "name": "WriteString",
          "doc": "WriteString writes a string at the given region-relative coordinates.\n",
          "signature": "func (r *Region) WriteString(x, y int, s string, style Style) int",
          "recv": "*Region"
        }
      ]
    },
    {
      "name": "Renderer",
      "doc": "Renderer is the extension interface for components that render directly.\nUnlike Component (which expands to primitives), Renderer draws to the\nbuffer itself. This is useful for custom widgets like charts, sparklines, etc.\n",
      "decl": "type Renderer interface {\n\t// MinSize returns the minimum dimensions needed by this component.\n\t// Called during layout phase.\n\tMinSize() (width, height int)\n\n\t// Render draws the component to the buffer at the given position.\n\t// w and h are the allocated dimensions (may be larger than MinSize).\n\tRender(buf *Buffer, x, y, w, h int)\n}"
    },
    {
      "name": "RichTextNode",
      "doc": "RichTextNode displays text with mixed inline styles.\nSpans can be []Span (static) or *[]Span (dynamic binding).\n",
      "decl": "type RichTextNode struct {\n\tFlex\n\tSpans any // []Span or *[]Span\n}",
      "constructors": [
        {
          "name": "Rich",
          "doc": "Rich creates a RichText from a mix of strings and Spans.\nPlain strings get default styling, Spans keep their styling.\n\nExample:\n\n\tRich(\"Hello \", Bold(\"world\"), \"!\")\n",
          "signature": "func Rich(parts ...any) RichTextNode",
          "examples": [
            {
              "doc": "Inline spans.\nMix Bold, Dim, Italic, FG and plain strings in a single line.\n",
              "code": "Rich(\n\tBold(\"Important: \"),\n\tDim(\"supporting detail\"),\n\tFG(\"error\", Red),\n)"
            }
          ]
        }
      ]
    },
    {
      "name": "Screen",
      "doc": "Screen manages the terminal display with double buffering and diff-based updates.\n",
      "decl": "type Screen struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "NewScreen",
          "doc": "NewScreen creates a new screen writing to the given writer.\nPass nil to use os.Stdout.\n",
          "signature": "func NewScreen(w io.Writer) (*Screen, error)"
        }
      ],
      "methods": [
        {
          "name": "Buffer",
          "doc": "Buffer returns the back buffer for drawing.\n",
          "signature": "func (s *Screen) Buffer() *Buffer",
          "recv": "*Screen"
        },
        {
          "name": "BufferCursor",
          "doc": "BufferCursor writes cursor positioning and visibility to the internal buffer.\nCall this before FlushBuffer() to batch cursor ops with content in one syscall.\n",
          "signature": "func (s *Screen) BufferCursor(x, y int, visible bool, shape CursorShape)",
          "recv": "*Screen"
        },
        {
          "name": "BufferCursorColor",
          "doc": "BufferCursorColor sets cursor color using OSC 12 escape sequence.\nFormat: OSC 12 ; #RRGGBB BEL\n",
          "signature": "func (s *Screen) BufferCursorColor(c Color)",
          "recv": "*Screen"
        },
        {
          "name": "Clear",
          "doc": "Clear clears the back buffer.\n",
          "signature": "func (s *Screen) Clear()",
          "recv": "*Screen"
        },
        {
          "name": "EnterInlineMode",
          "doc": "EnterInlineMode puts the terminal into raw mode WITHOUT alternate buffer.\nUse this for inline UI elements (progress bars, menus, etc.) that render\nin the normal terminal flow rather than taking over the screen.\n",
          "signature": "func (s *Screen) EnterInlineMode() error",
          "recv": "*Screen"
        },
        {
          "name": "EnterRawMode",
          "doc": "EnterRawMode puts the terminal into raw mode for TUI operation.\n",
          "signature": "func (s *Screen) EnterRawMode() error",
          "recv": "*Screen"
        },
        {
          "name": "ExitInlineMode",
          "doc": "ExitInlineMode restores the terminal from inline mode.\nIf clear is true, clears the lines used.\nIf clear is false, moves cursor below the rendered content.\n",
          "signature": "func (s *Screen) ExitInlineMode(linesUsed int, clear bool) error",
          "recv": "*Screen"
        },
        {
          "name": "ExitRawMode",
          "doc": "ExitRawMode restores the terminal to its original state.\n",
          "signature": "func (s *Screen) ExitRawMode() error",
          "recv": "*Screen"
        },
        {
          "name": "Flush",
          "doc": "Flush renders the back buffer to the terminal using per-cell diff.\nOnly cells that actually changed are written, with cursor positioning for each run.\nUses dirty row tracking to skip rows that haven't been modified.\n",
          "signature": "func (s *Screen) Flush()",
          "recv": "*Screen"
        },
        {
          "name": "FlushBuffer",
          "doc": "FlushBuffer writes the accumulated buffer to the terminal in one syscall.\n",
          "signature": "func (s *Screen) FlushBuffer()",
          "recv": "*Screen"
        },
        {
          "name": "FlushFull",
          "doc": "FlushFull does a complete redraw without diffing.\n",
          "signature": "func (s *Screen) FlushFull()",
          "recv": "*Screen"
        },
        {
          "name": "FlushInline",
          "doc": "FlushInline renders the buffer for inline mode (no alternate screen).\nRenders at current cursor position using relative movement.\nReturns the number of lines rendered for cleanup tracking.\n",
          "signature": "func (s *Screen) FlushInline(height int) int",
          "recv": "*Screen"
        },
        {
          "name": "Height",
          "doc": "Height returns the screen height.\n",
          "signature": "func (s *Screen) Height() int",
          "recv": "*Screen"
        },
        {
          "name": "HideCursor",
          "doc": "HideCursor hides the cursor.\n",
          "signature": "func (s *Screen) HideCursor()",
          "recv": "*Screen"
        },
        {
          "name": "IsInlineMode",
          "doc": "IsInlineMode returns true if the screen is in inline mode.\n",
          "signature": "func (s *Screen) IsInlineMode() bool",
          "recv": "*Screen"
        },
        {
          "name": "MoveCursor",
          "doc": "MoveCursor moves the cursor to the given position (0-indexed).\n",
          "signature": "func (s *Screen) MoveCursor(x, y int)",
          "recv": "*Screen"
        },
        {
          "name": "ResizeChan",
          "doc": "ResizeChan returns a channel that receives size updates on terminal resize.\n",
          "signature": "func (s *Screen) ResizeChan() \u003c-chan Size",
          "recv": "*Screen"
        },
        {
          "name": "SetCursorShape",
          "doc": "SetCursorShape changes the cursor shape.\n",
          "signature": "func (s *Screen) SetCursorShape(shape CursorShape)",
          "recv": "*Screen"
        },
        {
          "name": "ShowCursor",
          "doc": "ShowCursor makes the cursor visible.\n",
          "signature": "func (s *Screen) ShowCursor()",
          "recv": "*Screen"
        },
        {
          "name": "Size",
          "doc": "Size returns the current screen dimensions.\n",
          "signature": "func (s *Screen) Size() Size",
          "recv": "*Screen"
        },
        {
          "name": "Width",
          "doc": "Width returns the screen width.\n",
          "signature": "func (s *Screen) Width() int",
          "recv": "*Screen"
        }
      ]
    },
    {
      "name": "ScrollbarC",
      "doc": "",
      "decl": "type ScrollbarC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Scroll",
          "doc": "Scroll creates a scrollbar for tracking position in scrollable content.\n",
          "signature": "func Scroll(contentSize, viewSize int, position *int) ScrollbarC",
          "examples": [
            {
              "doc": "Scrollbar.\nParameters are total content height, visible viewport height, and a pointer to scroll position.\n",
              "code": "var pos int\nScroll(100, 20, \u0026pos)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Horizontal",
          "doc": "Horizontal renders the scrollbar horizontally instead of vertically.\n",
          "signature": "func (s ScrollbarC) Horizontal() ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "Length",
          "doc": "Length sets the scrollbar track length.\n",
          "signature": "func (s ScrollbarC) Length(l int16) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (s ScrollbarC) Margin(all int16) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (s ScrollbarC) MarginTRBL(a, b, c, d int16) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (s ScrollbarC) MarginVH(v, h int16) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "ThumbChar",
          "doc": "Char sets the display character.\n",
          "signature": "func (s ScrollbarC) ThumbChar(c rune) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "ThumbStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (s ScrollbarC) ThumbStyle(st Style) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "TrackChar",
          "doc": "Char sets the display character.\n",
          "signature": "func (s ScrollbarC) TrackChar(c rune) ScrollbarC",
          "recv": "ScrollbarC"
        },
        {
          "name": "TrackStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (s ScrollbarC) TrackStyle(st Style) ScrollbarC",
          "recv": "ScrollbarC"
        }
      ]
    },
    {
      "name": "ScrollbarNode",
      "doc": "ScrollbarNode displays a visual scroll indicator.\nVertical by default; set Horizontal to true for horizontal scrollbar.\n",
      "decl": "type ScrollbarNode struct {\n\tContentSize int   // total content size\n\tViewSize    int   // visible viewport size\n\tPosition    *int  // pointer to current scroll position\n\tLength      int16 // scrollbar length (0 = fill available)\n\tHorizontal  bool  // true for horizontal scrollbar\n\tTrackChar   rune  // track character (default: '│' or '─')\n\tThumbChar   rune  // thumb character (default: '█')\n\tTrackStyle  Style // track styling\n\tThumbStyle  Style // thumb styling\n}"
    },
    {
      "name": "SelectionList",
      "doc": "SelectionList displays a list of items with selection marker.\nItems must be a pointer to a slice (*[]T).\nSelected must be a pointer to an int (*int) tracking the selected index.\nRender is optional - if nil, items are rendered using fmt.Sprintf(\"%v\", item).\nMarker defaults to \"\u003e \" if not specified.\n",
      "decl": "type SelectionList struct {\n\tItems         any    // *[]T - pointer to slice of items\n\tSelected      *int   // pointer to selected index\n\tMarker        string // selection marker (default \"\u003e \", use \" \" for no visible marker)\n\tMarkerStyle   Style  // style for marker text (merged with SelectedStyle.BG for selected rows)\n\tRender        any    // func(*T) any - optional, renders each item\n\tMaxVisible    int    // max items to show (0 = all)\n\tStyle         Style  // default style for non-selected rows (e.g., background)\n\tSelectedStyle Style  // style for selected row (e.g., background color)\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Down",
          "doc": "Down moves selection down by one. Safe to use directly with app.Handle.\n",
          "signature": "func (s *SelectionList) Down(m any)",
          "recv": "*SelectionList"
        },
        {
          "name": "First",
          "doc": "First moves selection to the first item.\n",
          "signature": "func (s *SelectionList) First(m any)",
          "recv": "*SelectionList"
        },
        {
          "name": "Last",
          "doc": "Last moves selection to the last item.\n",
          "signature": "func (s *SelectionList) Last(m any)",
          "recv": "*SelectionList"
        },
        {
          "name": "PageDown",
          "doc": "PageDown moves selection down by page size (MaxVisible or 10).\n",
          "signature": "func (s *SelectionList) PageDown(m any)",
          "recv": "*SelectionList"
        },
        {
          "name": "PageUp",
          "doc": "PageUp moves selection up by page size (MaxVisible or 10).\n",
          "signature": "func (s *SelectionList) PageUp(m any)",
          "recv": "*SelectionList"
        },
        {
          "name": "Up",
          "doc": "Up moves selection up by one. Safe to use directly with app.Handle.\n",
          "signature": "func (s *SelectionList) Up(m any)",
          "recv": "*SelectionList"
        }
      ]
    },
    {
      "name": "Size",
      "doc": "Size represents dimensions.\n",
      "decl": "type Size struct {\n\tWidth  int\n\tHeight int\n}"
    },
    {
      "name": "SpacerC",
      "doc": "",
      "decl": "type SpacerC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Space",
          "doc": "Space creates a flexible empty spacer.\n",
          "signature": "func Space() SpacerC",
          "examples": [
            {
              "doc": "Flexible spacer.\nPushes siblings apart. In a VBox, it pushes content to the top and bottom.\n",
              "code": "VBox(\n\tText(\"header\"),\n\tSpace(),\n\tText(\"footer\"),\n)"
            }
          ]
        },
        {
          "name": "SpaceH",
          "doc": "SpaceH creates a vertical spacer with a fixed height.\n",
          "signature": "func SpaceH(h int16) SpacerC",
          "examples": [
            {
              "doc": "Fixed-height gap.\nUse in VBox to add exact spacing between elements.\n",
              "code": "VBox(\n\tText(\"above\"),\n\tSpaceH(2),\n\tText(\"below\"),\n)"
            }
          ]
        },
        {
          "name": "SpaceW",
          "doc": "SpaceW creates a horizontal spacer with a fixed width.\n",
          "signature": "func SpaceW(w int16) SpacerC",
          "examples": [
            {
              "doc": "Fixed-width gap.\nUse in HBox to add exact spacing between elements.\n",
              "code": "HBox(\n\tText(\"left\"),\n\tSpaceW(4),\n\tText(\"right\"),\n)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Char",
          "doc": "Char sets the display character.\n",
          "signature": "func (s SpacerC) Char(c rune) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (s SpacerC) Grow(g float32) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "Height",
          "doc": "Height sets a fixed height.\n",
          "signature": "func (s SpacerC) Height(h int16) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (s SpacerC) Margin(all int16) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (s SpacerC) MarginTRBL(a, b, c, d int16) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (s SpacerC) MarginVH(v, h int16) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (s SpacerC) Style(st Style) SpacerC",
          "recv": "SpacerC"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (s SpacerC) Width(w int16) SpacerC",
          "recv": "SpacerC"
        }
      ]
    },
    {
      "name": "SpacerNode",
      "doc": "SpacerNode creates empty space with specified dimensions.\nIf no dimensions are set, Spacer grows to fill available space (implicit Grow(1)).\nWith explicit Width/Height, it becomes a fixed-size spacer.\n\nExamples:\n  - Spacer{}              → fills available space (grows)\n  - Spacer{Height: 1}     → fixed 1-line vertical gap\n  - Spacer{Width: 10}     → fixed 10-char horizontal gap\n  - Spacer{}.Grow(2)      → grows with weight 2\n  - Spacer{Char: '.'}     → dotted leader (fills with dots)\n",
      "decl": "type SpacerNode struct {\n\tWidth  int16 // fixed width (0 = grow to fill)\n\tHeight int16 // fixed height (0 = grow to fill, but defaults to 1 in VBox if not growing)\n\tChar   rune  // fill character (0 = empty space)\n\tStyle  Style // style for fill character\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "FG",
          "doc": "FG sets the foreground color for the fill character.\n",
          "signature": "func (s SpacerNode) FG(c Color) SpacerNode",
          "recv": "SpacerNode"
        },
        {
          "name": "Grow",
          "doc": "Grow sets flex grow factor for Spacer.\n",
          "signature": "func (s SpacerNode) Grow(g float32) SpacerNode",
          "recv": "SpacerNode"
        }
      ]
    },
    {
      "name": "Span",
      "doc": "Span represents a styled segment of text within RichText.\n",
      "decl": "type Span struct {\n\tText  string\n\tStyle Style\n}",
      "constructors": [
        {
          "name": "BG",
          "doc": "BG creates a span with background color.\n",
          "signature": "func BG(text string, color Color) Span"
        },
        {
          "name": "Bold",
          "doc": "Bold creates a bold text span.\n",
          "signature": "func Bold(text string) Span"
        },
        {
          "name": "Dim",
          "doc": "Dim creates a dim text span.\n",
          "signature": "func Dim(text string) Span"
        },
        {
          "name": "FG",
          "doc": "FG creates a span with foreground color.\n",
          "signature": "func FG(text string, color Color) Span"
        },
        {
          "name": "Inverse",
          "doc": "Inverse creates an inverse text span.\n",
          "signature": "func Inverse(text string) Span"
        },
        {
          "name": "Italic",
          "doc": "Italic creates an italic text span.\n",
          "signature": "func Italic(text string) Span"
        },
        {
          "name": "Styled",
          "doc": "Styled creates a span with the given style.\n",
          "signature": "func Styled(text string, style Style) Span"
        },
        {
          "name": "Underline",
          "doc": "Underline creates an underlined text span.\n",
          "signature": "func Underline(text string) Span"
        }
      ],
      "examples": [
        {
          "doc": "Custom span styles.\nStyled creates a span with a full Style struct for fine-grained control.\n",
          "code": "Rich(\n\tStyled(\"custom\", Style{FG: Hex(0xFF5500), Attr: AttrBold}),\n\t\" mixed with \",\n\tItalic(\"emphasis\"),\n)"
        }
      ]
    },
    {
      "name": "SparklineC",
      "doc": "",
      "decl": "type SparklineC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Sparkline",
          "doc": "Sparkline creates a mini chart from a slice of values.\n",
          "signature": "func Sparkline(values any) SparklineC",
          "examples": [
            {
              "doc": "Mini chart.\nA line chart from a float64 slice pointer. Append values and trigger a render to update.\n",
              "code": "values := []float64{1, 3, 5, 2, 8, 4}\n\nSparkline(\u0026values).Width(20).FG(Green)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (s SparklineC) BG(c Color) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (s SparklineC) Bold() SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (s SparklineC) FG(c Color) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (s SparklineC) Margin(all int16) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (s SparklineC) MarginTRBL(a, b, c, d int16) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (s SparklineC) MarginVH(v, h int16) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "Range",
          "doc": "Range sets the min and max value range for the chart.\n",
          "signature": "func (s SparklineC) Range(min, max float64) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (s SparklineC) Style(st Style) SparklineC",
          "recv": "SparklineC"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (s SparklineC) Width(w int16) SparklineC",
          "recv": "SparklineC"
        }
      ]
    },
    {
      "name": "SparklineNode",
      "doc": "SparklineNode displays a mini chart using Unicode block characters.\nValues are normalized to fit within the available height (1 character).\nUses: ▁▂▃▄▅▆▇█\n",
      "decl": "type SparklineNode struct {\n\tValues any     // []float64 or *[]float64\n\tWidth  int16   // width (0 = auto from data length)\n\tMin    float64 // minimum value (0 = auto-detect)\n\tMax    float64 // maximum value (0 = auto-detect)\n\tStyle  Style   // styling\n}"
    },
    {
      "name": "SpinnerC",
      "doc": "",
      "decl": "type SpinnerC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Spinner",
          "doc": "Spinner creates an animated spinner bound to a frame counter.\n",
          "signature": "func Spinner(frame *int) SpinnerC",
          "examples": [
            {
              "doc": "Animated spinner.\nThe frame pointer is advanced by the framework on each render tick.\n",
              "code": "var frame int\n\nSpinner(\u0026frame).Frames(SpinnerBraille)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (s SpinnerC) BG(c Color) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (s SpinnerC) Bold() SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (s SpinnerC) FG(c Color) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "Frames",
          "doc": "Frames sets the animation frames.\n",
          "signature": "func (s SpinnerC) Frames(f []string) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (s SpinnerC) Margin(all int16) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (s SpinnerC) MarginTRBL(a, b, c, d int16) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (s SpinnerC) MarginVH(v, h int16) SpinnerC",
          "recv": "SpinnerC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (s SpinnerC) Style(st Style) SpinnerC",
          "recv": "SpinnerC"
        }
      ]
    },
    {
      "name": "SpinnerNode",
      "doc": "SpinnerNode displays an animated loading indicator.\nThe Frame pointer controls which animation frame to show.\nIncrement Frame and re-render to animate.\n",
      "decl": "type SpinnerNode struct {\n\tFrame  *int     // pointer to current frame index\n\tFrames []string // custom frames (nil = default braille spinner)\n\tStyle  Style    // styling\n}"
    },
    {
      "name": "StringValidator",
      "doc": "StringValidator validates a string value.\n",
      "decl": "type StringValidator func(string) error",
      "constructors": [
        {
          "name": "VMatch",
          "doc": "VMatch rejects strings that don't match the given regex pattern.\n",
          "signature": "func VMatch(pattern string) StringValidator"
        },
        {
          "name": "VMaxLen",
          "doc": "VMaxLen rejects strings longer than n.\n",
          "signature": "func VMaxLen(n int) StringValidator"
        },
        {
          "name": "VMinLen",
          "doc": "VMinLen rejects strings shorter than n.\n",
          "signature": "func VMinLen(n int) StringValidator"
        }
      ]
    },
    {
      "name": "Style",
      "doc": "Style combines foreground, background colours and attributes.\n",
      "decl": "type Style struct {\n\tFG        Color\n\tBG        Color // text background (behind characters)\n\tFill      Color // container fill (entire area)\n\tAttr      Attribute\n\tTransform TextTransform // text case transformation (uppercase, lowercase, etc.)\n\tAlign     Align         // text alignment within allocated width\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "DefaultStyle",
          "doc": "DefaultStyle returns a style with default colours and no attributes.\n",
          "signature": "func DefaultStyle() Style",
          "examples": [
            {
              "doc": "Style chaining.\nBuild a style by chaining methods on DefaultStyle. CascadeStyle on a container applies it to all descendants.\n",
              "code": "s := DefaultStyle().Bold().Foreground(Cyan)\n\nVBox.CascadeStyle(\u0026s)(\n\tText(\"all children inherit bold cyan\"),\n)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Background",
          "doc": "Background returns a new style with the given background color.\n",
          "signature": "func (s Style) Background(c Color) Style",
          "recv": "Style"
        },
        {
          "name": "Bold",
          "doc": "Bold returns a new style with bold enabled.\n",
          "signature": "func (s Style) Bold() Style",
          "recv": "Style"
        },
        {
          "name": "Capitalize",
          "doc": "Capitalize returns a new style with capitalize transform (first letter of each word).\n",
          "signature": "func (s Style) Capitalize() Style",
          "recv": "Style"
        },
        {
          "name": "Dim",
          "doc": "Dim returns a new style with dim enabled.\n",
          "signature": "func (s Style) Dim() Style",
          "recv": "Style"
        },
        {
          "name": "Equal",
          "doc": "Equal returns true if two styles are equal.\n",
          "signature": "func (s Style) Equal(other Style) bool",
          "recv": "Style"
        },
        {
          "name": "FillColor",
          "doc": "FillColor returns a new style with the given fill color (for containers).\n",
          "signature": "func (s Style) FillColor(c Color) Style",
          "recv": "Style"
        },
        {
          "name": "Foreground",
          "doc": "Foreground returns a new style with the given foreground color.\n",
          "signature": "func (s Style) Foreground(c Color) Style",
          "recv": "Style"
        },
        {
          "name": "Inverse",
          "doc": "Inverse returns a new style with inverse enabled.\n",
          "signature": "func (s Style) Inverse() Style",
          "recv": "Style"
        },
        {
          "name": "Italic",
          "doc": "Italic returns a new style with italic enabled.\n",
          "signature": "func (s Style) Italic() Style",
          "recv": "Style"
        },
        {
          "name": "Lowercase",
          "doc": "Lowercase returns a new style with lowercase text transform.\n",
          "signature": "func (s Style) Lowercase() Style",
          "recv": "Style"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (s Style) Margin(all int16) Style",
          "recv": "Style"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (s Style) MarginTRBL(t, r, b, l int16) Style",
          "recv": "Style"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (s Style) MarginVH(v, h int16) Style",
          "recv": "Style"
        },
        {
          "name": "Strikethrough",
          "doc": "Strikethrough returns a new style with strikethrough enabled.\n",
          "signature": "func (s Style) Strikethrough() Style",
          "recv": "Style"
        },
        {
          "name": "Underline",
          "doc": "Underline returns a new style with underline enabled.\n",
          "signature": "func (s Style) Underline() Style",
          "recv": "Style"
        },
        {
          "name": "Uppercase",
          "doc": "Uppercase returns a new style with uppercase text transform.\n",
          "signature": "func (s Style) Uppercase() Style",
          "recv": "Style"
        }
      ],
      "examples": [
        {
          "doc": "Struct literal.\nConstruct a Style directly when you know the exact fields. Attr flags combine with bitwise OR.\n",
          "code": "highlight := Style{FG: Yellow, Attr: AttrBold | AttrUnderline}\n\nText(\"warning\").Style(highlight)"
        },
        {
          "name": "margin",
          "doc": "Style margin.\nMargin is part of Style. Values are top, right, bottom, left (CSS order).\n",
          "code": "padded := DefaultStyle().MarginTRBL(1, 2, 1, 2)\n\nText(\"padded text\").Style(padded)"
        }
      ]
    },
    {
      "name": "SwitchBuilder",
      "doc": "SwitchBuilder for type-safe multi-way branching.\n",
      "decl": "type SwitchBuilder[T comparable] struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Switch",
          "doc": "Switch starts a multi-way branch. Type-safe via generics:\n\n\tSwitch(\u0026state.Tab).\n\t    Case(\"home\", homeView).\n\t    Case(\"settings\", settingsView).\n\t    Default(notFoundView)\n",
          "signature": "func Switch[T comparable](ptr *T) *SwitchBuilder[T]",
          "examples": [
            {
              "doc": "Multi-way branch.\nBranch on a value with named cases. Default catches unmatched values.\n",
              "code": "mode := \"edit\"\nSwitch(\u0026mode).\n\tCase(\"edit\", Text(\"editing\")).\n\tCase(\"preview\", Text(\"previewing\")).\n\tDefault(Text(\"idle\"))"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "Case",
          "doc": "Case adds a branch for when *ptr == val\n",
          "signature": "func (s *SwitchBuilder[T]) Case(val T, node any) *SwitchBuilder[T]",
          "recv": "*SwitchBuilder[T]"
        },
        {
          "name": "Default",
          "doc": "Default sets the fallback when no case matches.\nReturns SwitchNode which implements the compiler interface.\n",
          "signature": "func (s *SwitchBuilder[T]) Default(node any) *SwitchNode[T]",
          "recv": "*SwitchBuilder[T]"
        },
        {
          "name": "End",
          "doc": "End finalizes without a default (renders nothing if no match)\n",
          "signature": "func (s *SwitchBuilder[T]) End() *SwitchNode[T]",
          "recv": "*SwitchBuilder[T]"
        }
      ]
    },
    {
      "name": "SwitchNode",
      "doc": "SwitchNode is the final compiled switch statement\n",
      "decl": "type SwitchNode[T comparable] struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "Table",
      "doc": "Table displays tabular data with columns and optional headers.\nUses pointer bindings for dynamic data updates.\n",
      "decl": "type Table struct {\n\tColumns     []TableColumn // column definitions\n\tRows        any           // *[][]string - pointer to row data\n\tShowHeader  bool          // show header row\n\tHeaderStyle Style         // style for header row\n\tRowStyle    Style         // style for data rows\n\tAltRowStyle Style         // style for alternating rows (if non-zero)\n}"
    },
    {
      "name": "TableColumn",
      "doc": "TableColumn defines a column in a Table.\n",
      "decl": "type TableColumn struct {\n\tHeader string // column header text\n\tWidth  int    // column width (0 = auto-size)\n\tAlign  Align  // text alignment\n}"
    },
    {
      "name": "TabsC",
      "doc": "",
      "decl": "type TabsC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Tabs",
          "doc": "Tabs creates a tab header bar.\n",
          "signature": "func Tabs(labels []string, selected *int) TabsC",
          "examples": [
            {
              "doc": "Tab bar.\nBound to an int pointer. The selected index is written when the user picks a tab.\n",
              "code": "var active int\ntabs := []string{\"General\", \"Advanced\", \"About\"}\n\nTabs(tabs, \u0026active)"
            },
            {
              "name": "styled",
              "doc": "Custom tab styles.\nCustomize appearance with Kind for the shape and per-state styles for active/inactive tabs.\n",
              "code": "var active int\ntabs := []string{\"Code\", \"Preview\", \"Settings\"}\n\nTabs(tabs, \u0026active).\n\tKind(TabsStyleBox).\n\tActiveStyle(Style{FG: Cyan, Attr: AttrBold}).\n\tInactiveStyle(Style{FG: BrightBlack})"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "ActiveStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (t TabsC) ActiveStyle(s Style) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between children.\n",
          "signature": "func (t TabsC) Gap(g int8) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "InactiveStyle",
          "doc": "Style sets the component style.\n",
          "signature": "func (t TabsC) InactiveStyle(s Style) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "Kind",
          "doc": "Kind sets the tab rendering style.\n",
          "signature": "func (t TabsC) Kind(s TabsStyle) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (t TabsC) Margin(all int16) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (t TabsC) MarginTRBL(a, b, c, d int16) TabsC",
          "recv": "TabsC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (t TabsC) MarginVH(v, h int16) TabsC",
          "recv": "TabsC"
        }
      ]
    },
    {
      "name": "TabsNode",
      "doc": "TabsNode displays a row of tab headers with active tab indicator.\n",
      "decl": "type TabsNode struct {\n\tLabels        []string  // tab labels\n\tSelected      *int      // pointer to selected tab index\n\tStyle         TabsStyle // visual style\n\tGap           int       // gap between tabs (default: 2)\n\tActiveStyle   Style     // style for active tab\n\tInactiveStyle Style     // style for inactive tabs\n}"
    },
    {
      "name": "TabsStyle",
      "doc": "TabsStyle defines the visual style for tab headers.\n",
      "decl": "type TabsStyle uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "TabsStyleUnderline",
            "TabsStyleBox",
            "TabsStyleBracket"
          ],
          "decl": "const (\n\tTabsStyleUnderline TabsStyle = iota // active tab has underline\n\tTabsStyleBox                        // tabs in boxes\n\tTabsStyleBracket                    // tabs with [ ] brackets\n)"
        }
      ],
      "examples": [
        {
          "doc": "Tab shapes.\nThree tab styles: TabsStyleUnderline (default), TabsStyleBox, and TabsStyleBracket.\n",
          "code": "var active int\ntabs := []string{\"Files\", \"Search\", \"Git\"}\n\nTabs(tabs, \u0026active).Kind(TabsStyleBracket)"
        }
      ]
    },
    {
      "name": "Template",
      "doc": "Template is a compiled UI template.\nCompile does all reflection. Execute is pure pointer arithmetic.\n",
      "decl": "type Template struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Build",
          "doc": "Build compiles a declarative UI into a Template.\n",
          "signature": "func Build(ui any) *Template",
          "examples": [
            {
              "doc": "Compile a template.\nBuild compiles a UI tree into a Template — the same step that SetView performs internally. Useful for rendering into a Layer or for headless testing.\n",
              "code": "tmpl := Build(VBox(\n\tText(\"hello\"),\n\tText(\"world\"),\n))\n\nbuf := NewBuffer(80, 24)\ntmpl.Execute(buf, 80, 24)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "DebugDump",
          "doc": "DebugDump prints the template's op tree for debugging layout issues.\n",
          "signature": "func (t *Template) DebugDump(prefix string)",
          "recv": "*Template"
        },
        {
          "name": "Execute",
          "doc": "Execute runs all three phases and renders to the buffer.\n",
          "signature": "func (t *Template) Execute(buf *Buffer, screenW, screenH int16)",
          "recv": "*Template"
        },
        {
          "name": "Height",
          "doc": "Height returns the computed height after layout.\nMust call Execute first.\n",
          "signature": "func (t *Template) Height() int16",
          "recv": "*Template"
        },
        {
          "name": "SetApp",
          "doc": "SetApp links this template to an App for jump mode support.\n",
          "signature": "func (t *Template) SetApp(a *App)",
          "recv": "*Template"
        }
      ]
    },
    {
      "name": "TextC",
      "doc": "",
      "decl": "type TextC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "Text",
          "doc": "Text creates a text display component.\n",
          "signature": "func Text(content any) TextC",
          "examples": [
            {
              "doc": "Static text.\nText that never changes. Pass a string literal directly.\n",
              "code": "Text(\"hello world\")"
            },
            {
              "name": "pointer",
              "doc": "Pointer binding.\nPass a pointer so the rendered text reflects the current value. Mutate the string, then trigger a render to see it.\n",
              "code": "msg := \"dynamic\"\nText(\u0026msg)"
            },
            {
              "name": "styled",
              "doc": "Inline styling.\nChain style methods. Bold, Dim, Italic, Underline, and FG/BG are all available.\n",
              "code": "msg := \"styled\"\nText(\u0026msg).Bold().FG(Cyan)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (t TextC) BG(c Color) TextC",
          "recv": "TextC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (t TextC) Bold() TextC",
          "recv": "TextC"
        },
        {
          "name": "Dim",
          "doc": "Dim enables dim text.\n",
          "signature": "func (t TextC) Dim() TextC",
          "recv": "TextC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (t TextC) FG(c Color) TextC",
          "recv": "TextC"
        },
        {
          "name": "Inverse",
          "doc": "Inverse enables inverse (reverse video) text.\n",
          "signature": "func (t TextC) Inverse() TextC",
          "recv": "TextC"
        },
        {
          "name": "Italic",
          "doc": "Italic enables italic text.\n",
          "signature": "func (t TextC) Italic() TextC",
          "recv": "TextC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (t TextC) Margin(all int16) TextC",
          "recv": "TextC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (t TextC) MarginTRBL(a, b, c, d int16) TextC",
          "recv": "TextC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (t TextC) MarginVH(v, h int16) TextC",
          "recv": "TextC"
        },
        {
          "name": "Strikethrough",
          "doc": "Strikethrough enables strikethrough text.\n",
          "signature": "func (t TextC) Strikethrough() TextC",
          "recv": "TextC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (t TextC) Style(s Style) TextC",
          "recv": "TextC"
        },
        {
          "name": "Underline",
          "doc": "Underline enables underline text.\n",
          "signature": "func (t TextC) Underline() TextC",
          "recv": "TextC"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (t TextC) Width(w int16) TextC",
          "recv": "TextC"
        }
      ]
    },
    {
      "name": "TextInput",
      "doc": "TextInput is a single-line text input field.\nWire up input handling via riffkey.NewTextHandler or riffkey.NewFieldHandler.\n\nExample with InputState + FocusGroup (recommended for forms):\n\n\tname := tui.InputState{}\n\tfocus := tui.FocusGroup{}\n\ttui.TextInput{Field: \u0026name, FocusGroup: \u0026focus, FocusIndex: 0}\n\nExample with separate pointers (for single fields):\n\n\ttui.TextInput{Value: \u0026query, Cursor: \u0026cursor, Placeholder: \"Search...\"}\n",
      "decl": "type TextInput struct {\n\t// Field-based API (recommended for forms)\n\tField      *InputState // Bundles Value + Cursor in one struct\n\tFocusGroup *FocusGroup // Shared focus tracker - cursor shows when FocusGroup.Current == FocusIndex\n\tFocusIndex int         // This field's index in the focus group\n\n\t// Pointer-based API (for single fields)\n\tValue   *string // Bound text value (ignored if Field is set)\n\tCursor  *int    // Cursor position (ignored if Field is set)\n\tFocused *bool   // Show cursor only when true (ignored if FocusGroup is set)\n\n\t// Common options\n\tPlaceholder      string // Shown when value is empty\n\tWidth            int    // Field width (0 = fill available)\n\tMask             rune   // Password mask character (0 = none)\n\tStyle            Style  // Text style\n\tPlaceholderStyle Style  // Placeholder style (zero = dim text)\n\tCursorStyle      Style  // Cursor style (zero = reverse video)\n}"
    },
    {
      "name": "TextNode",
      "doc": "TextNode displays text content.\n",
      "decl": "type TextNode struct {\n\tFlex\n\tContent any   // string or *string\n\tStyle   Style // styling (use Attr for bold, dim, etc.)\n}"
    },
    {
      "name": "TextTransform",
      "doc": "TextTransform represents text case transformations.\n",
      "decl": "type TextTransform uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "TransformNone",
            "TransformUppercase",
            "TransformLowercase",
            "TransformCapitalize"
          ],
          "decl": "const (\n\tTransformNone TextTransform = iota\n\tTransformUppercase\n\tTransformLowercase\n\tTransformCapitalize // first letter of each word\n)"
        }
      ],
      "examples": [
        {
          "doc": "Case transform.\nTransform text case via the Style struct. Transforms run at render time without modifying the source string.\n",
          "code": "Text(\"hello world\").Style(Style{Transform: TransformUppercase})"
        }
      ]
    },
    {
      "name": "TextViewC",
      "doc": "TextViewC displays multi-line text with word wrapping in a layer-backed viewport.\nContent is re-wrapped only when the text or viewport width changes.\n",
      "decl": "type TextViewC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "TextView",
          "doc": "TextView creates a multi-line text display that wraps to its container width.\n",
          "signature": "func TextView(content *string) *TextViewC"
        }
      ],
      "methods": [
        {
          "name": "BindPageScroll",
          "doc": "BindPageScroll registers keys for half-page scrolling.\n",
          "signature": "func (tv *TextViewC) BindPageScroll(down, up string) *TextViewC",
          "recv": "*TextViewC"
        },
        {
          "name": "BindScroll",
          "doc": "BindScroll registers keys for line-by-line scrolling.\n",
          "signature": "func (tv *TextViewC) BindScroll(down, up string) *TextViewC",
          "recv": "*TextViewC"
        },
        {
          "name": "Grow",
          "doc": "",
          "signature": "func (tv *TextViewC) Grow(g float32) *TextViewC",
          "recv": "*TextViewC"
        },
        {
          "name": "Layer",
          "doc": "Layer returns the underlying layer for external scroll wiring.\n",
          "signature": "func (tv *TextViewC) Layer() *Layer",
          "recv": "*TextViewC"
        },
        {
          "name": "Margin",
          "doc": "",
          "signature": "func (tv *TextViewC) Margin(all int16) *TextViewC",
          "recv": "*TextViewC"
        },
        {
          "name": "MarginTRBL",
          "doc": "",
          "signature": "func (tv *TextViewC) MarginTRBL(t, r, b, l int16) *TextViewC",
          "recv": "*TextViewC"
        },
        {
          "name": "MarginVH",
          "doc": "",
          "signature": "func (tv *TextViewC) MarginVH(v, h int16) *TextViewC",
          "recv": "*TextViewC"
        }
      ]
    },
    {
      "name": "ThemeEx",
      "doc": "ThemeEx provides a set of styles for consistent UI appearance.\nUse CascadeStyle on containers to apply theme styles to children.\n",
      "decl": "type ThemeEx struct {\n\tBase   Style // default text style\n\tMuted  Style // de-emphasized text\n\tAccent Style // highlighted/important text\n\tError  Style // error messages\n\tBorder Style // border/divider style\n}",
      "examples": [
        {
          "doc": "Predefined theme.\nCascadeStyle sets the base style for all descendants; individual elements can override with per-element styles.\n",
          "code": "theme := ThemeDark\n\nVBox.CascadeStyle(\u0026theme.Base).Border(BorderRounded).BorderFG(theme.Border.FG)(\n\tText(\"normal text\"),\n\tText(\"muted\").Style(theme.Muted),\n\tText(\"accent\").Style(theme.Accent),\n\tText(\"error!\").Style(theme.Error),\n)"
        }
      ]
    },
    {
      "name": "Timings",
      "doc": "Timings holds timing data for the last frame.\n",
      "decl": "type Timings struct {\n\tBuildUs  float64 // Build time in microseconds\n\tLayoutUs float64 // Layout time in microseconds\n\tRenderUs float64 // Render time in microseconds\n\tFlushUs  float64 // Flush time in microseconds\n}",
      "constructors": [
        {
          "name": "GetTimings",
          "doc": "GetTimings returns the timing data for the last frame.\n",
          "signature": "func GetTimings() Timings"
        }
      ]
    },
    {
      "name": "TreeNode",
      "doc": "TreeNode represents a node in a tree structure.\n",
      "decl": "type TreeNode struct {\n\tLabel    string      // display label\n\tChildren []*TreeNode // child nodes\n\tExpanded bool        // whether children are visible\n\tData     any         // optional user data\n}"
    },
    {
      "name": "TreeView",
      "doc": "TreeView displays a hierarchical tree structure.\n",
      "decl": "type TreeView struct {\n\tRoot          *TreeNode // root node (can be hidden)\n\tShowRoot      bool      // whether to display the root node\n\tIndent        int       // indentation per level (default: 2)\n\tShowLines     bool      // show connecting lines (├ └ │)\n\tExpandedChar  rune      // character for expanded nodes (default: '▼')\n\tCollapsedChar rune      // character for collapsed nodes (default: '▶')\n\tLeafChar      rune      // character for leaf nodes (default: ' ')\n\tStyle         Style     // styling for labels\n}",
      "examples": [
        {
          "doc": "Collapsible tree.\nTreeView renders a collapsible tree from TreeNode structs. Set Expanded to control which nodes start open.\n",
          "code": "root := \u0026TreeNode{\n\tLabel: \"src\",\n\tChildren: []*TreeNode{\n\t\t{Label: \"main.go\"},\n\t\t{Label: \"lib\", Children: []*TreeNode{\n\t\t\t{Label: \"utils.go\"},\n\t\t\t{Label: \"types.go\"},\n\t\t}},\n\t},\n\tExpanded: true,\n}\n\n_ = TreeView{Root: root, ShowRoot: true, Indent: 2, ShowLines: true}"
        }
      ]
    },
    {
      "name": "VBoxC",
      "doc": "",
      "decl": "type VBoxC struct {\n\t// contains filtered or unexported fields\n}"
    },
    {
      "name": "VBoxFn",
      "doc": "",
      "decl": "type VBoxFn func(children ...any) VBoxC",
      "methods": [
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (f VBoxFn) Border(b BorderStyle) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "BorderBG",
          "doc": "BG sets the background color.\n",
          "signature": "func (f VBoxFn) BorderBG(c Color) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "BorderFG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (f VBoxFn) BorderFG(c Color) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "CascadeStyle",
          "doc": "CascadeStyle sets a style pointer that children inherit.\n",
          "signature": "func (f VBoxFn) CascadeStyle(s *Style) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Fill",
          "doc": "Fill sets the background fill color.\n",
          "signature": "func (f VBoxFn) Fill(c Color) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "FitContent",
          "doc": "FitContent sizes the container to fit its content.\n",
          "signature": "func (f VBoxFn) FitContent() VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Gap",
          "doc": "Gap sets the spacing between children.\n",
          "signature": "func (f VBoxFn) Gap(g int8) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Grow",
          "doc": "Grow sets the flex grow factor.\n",
          "signature": "func (f VBoxFn) Grow(g float32) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Height",
          "doc": "Height sets a fixed height.\n",
          "signature": "func (f VBoxFn) Height(h int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (f VBoxFn) Margin(all int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (f VBoxFn) MarginTRBL(top, right, bottom, left int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (f VBoxFn) MarginVH(vertical, horizontal int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Size",
          "doc": "Size sets a fixed width and height.\n",
          "signature": "func (f VBoxFn) Size(w, h int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Title",
          "doc": "Title sets the border title text.\n",
          "signature": "func (f VBoxFn) Title(t string) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "Width",
          "doc": "Width sets a fixed width.\n",
          "signature": "func (f VBoxFn) Width(w int16) VBoxFn",
          "recv": "VBoxFn"
        },
        {
          "name": "WidthPct",
          "doc": "WidthPct sets width as a percentage of the parent (0.0-1.0).\n",
          "signature": "func (f VBoxFn) WidthPct(pct float32) VBoxFn",
          "recv": "VBoxFn"
        }
      ],
      "vars": [
        {
          "doc": "VBox is the vertical container constructor\n",
          "names": [
            "VBox"
          ],
          "decl": "var VBox VBoxFn = func(children ...any) VBoxC {\n\treturn VBoxC{children: children}\n}"
        }
      ],
      "examples": [
        {
          "doc": "Vertical stack.\nCall VBox directly with children to stack them top to bottom.\n",
          "code": "VBox(\n\tText(\"First\"),\n\tText(\"Second\"),\n\tText(\"Third\"),\n)"
        },
        {
          "name": "chained",
          "doc": "Template syntax.\nChain methods to configure, then call as a function with children. Configure once, render many.\n",
          "code": "VBox.Gap(1).Border(BorderRounded)(\n\tText(\"First\"),\n\tText(\"Second\"),\n)"
        },
        {
          "name": "grow",
          "doc": "Flex growth.\nGrow fills available space. CascadeStyle passes a style to all descendants.\n",
          "code": "VBox.Grow(1).CascadeStyle(\u0026Style{FG: White})(\n\tText(\"header\"),\n\tText(\"content\"),\n\tText(\"footer\"),\n)"
        }
      ]
    },
    {
      "name": "VBoxNode",
      "doc": "VBoxNode arranges children vertically.\n",
      "decl": "type VBoxNode struct {\n\tChildren     []any\n\tTitle        string // title for bordered containers\n\tGap          int8\n\tCascadeStyle *Style // style inherited by children (pointer for dynamic themes)\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Border",
          "doc": "Border sets the border style.\n",
          "signature": "func (c VBoxNode) Border(b BorderStyle) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "BorderBG",
          "doc": "BorderBG sets the border background color.\n",
          "signature": "func (c VBoxNode) BorderBG(bg Color) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "BorderFG",
          "doc": "BorderFG sets the border foreground color.\n",
          "signature": "func (c VBoxNode) BorderFG(fg Color) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "Grow",
          "doc": "Grow sets flex grow factor.\n",
          "signature": "func (c VBoxNode) Grow(g float32) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "Height",
          "doc": "Height sets explicit height in lines.\n",
          "signature": "func (c VBoxNode) Height(h int16) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (c VBoxNode) Margin(all int16) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for each side.\n",
          "signature": "func (c VBoxNode) MarginTRBL(top, right, bottom, left int16) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (c VBoxNode) MarginVH(vertical, horizontal int16) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "Width",
          "doc": "Width sets explicit width in characters.\n",
          "signature": "func (c VBoxNode) Width(w int16) VBoxNode",
          "recv": "VBoxNode"
        },
        {
          "name": "WidthPct",
          "doc": "WidthPct sets width as percentage of parent (0.5 = 50%).\n",
          "signature": "func (c VBoxNode) WidthPct(pct float32) VBoxNode",
          "recv": "VBoxNode"
        }
      ]
    },
    {
      "name": "VRuleC",
      "doc": "",
      "decl": "type VRuleC struct {\n\t// contains filtered or unexported fields\n}",
      "constructors": [
        {
          "name": "VRule",
          "doc": "VRule creates a vertical rule.\n",
          "signature": "func VRule() VRuleC",
          "examples": [
            {
              "doc": "Vertical divider.\nA line that fills the available height.\n",
              "code": "HBox(\n\tText(\"left\"),\n\tVRule(),\n\tText(\"right\"),\n)"
            }
          ]
        }
      ],
      "methods": [
        {
          "name": "BG",
          "doc": "BG sets the background color.\n",
          "signature": "func (v VRuleC) BG(c Color) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "Bold",
          "doc": "Bold enables bold text.\n",
          "signature": "func (v VRuleC) Bold() VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "Char",
          "doc": "Char sets the display character.\n",
          "signature": "func (v VRuleC) Char(c rune) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "FG",
          "doc": "FG sets the foreground color.\n",
          "signature": "func (v VRuleC) FG(c Color) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "Height",
          "doc": "Height sets a fixed height.\n",
          "signature": "func (v VRuleC) Height(h int16) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "Margin",
          "doc": "Margin sets uniform margin on all sides.\n",
          "signature": "func (v VRuleC) Margin(all int16) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "MarginTRBL",
          "doc": "MarginTRBL sets individual margins for top, right, bottom, left.\n",
          "signature": "func (v VRuleC) MarginTRBL(a, b, c, d int16) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "MarginVH",
          "doc": "MarginVH sets vertical and horizontal margin.\n",
          "signature": "func (v VRuleC) MarginVH(vt, hz int16) VRuleC",
          "recv": "VRuleC"
        },
        {
          "name": "Style",
          "doc": "Style sets the component style.\n",
          "signature": "func (v VRuleC) Style(s Style) VRuleC",
          "recv": "VRuleC"
        }
      ]
    },
    {
      "name": "VRuleNode",
      "doc": "VRuleNode draws a vertical line that fills available height.\nDefault character is '│' (box drawing light vertical).\n",
      "decl": "type VRuleNode struct {\n\tChar  rune  // line character (0 = '│')\n\tStyle Style // styling\n}"
    },
    {
      "name": "ValidateOn",
      "doc": "ValidateOn controls when validation runs. Combine with bitwise OR.\n",
      "decl": "type ValidateOn uint8",
      "consts": [
        {
          "doc": "",
          "names": [
            "VOnChange",
            "VOnBlur",
            "VOnSubmit"
          ],
          "decl": "const (\n\tVOnChange ValidateOn = 1 \u003c\u003c iota // validate on every keystroke\n\tVOnBlur                          // validate when field loses focus\n\tVOnSubmit                        // validate on form submit\n)"
        }
      ]
    },
    {
      "name": "ViewBuilder",
      "doc": "ViewBuilder allows chaining Handle() calls after View().\n",
      "decl": "type ViewBuilder struct {\n\t// contains filtered or unexported fields\n}",
      "methods": [
        {
          "name": "Handle",
          "doc": "Handle registers a key handler for this view.\nAccepts func(riffkey.Match), func(any), or func() for convenience.\nAutomatically requests a re-render after the handler runs.\n",
          "signature": "func (vb *ViewBuilder) Handle(pattern string, handler any) *ViewBuilder",
          "recv": "*ViewBuilder"
        },
        {
          "name": "NoCounts",
          "doc": "NoCounts disables vim-style count prefixes (e.g., 5j) for this view.\nUse this when the view has text input so digits can be typed.\n",
          "signature": "func (vb *ViewBuilder) NoCounts() *ViewBuilder",
          "recv": "*ViewBuilder"
        },
        {
          "name": "Ref",
          "doc": "Ref provides access to the component for external references.\n",
          "signature": "func (vb *ViewBuilder) Ref(f func(*ViewBuilder)) *ViewBuilder",
          "recv": "*ViewBuilder"
        }
      ],
      "examples": [
        {
          "doc": "Views with text input.\nNoCounts disables vim-style count prefixes, preventing number keys from being swallowed before reaching an input.\n",
          "code": "app, _ := NewApp()\n\nvar name string\napp.View(\"editor\",\n\tVBox(\n\t\tText(\"Editor\"),\n\t\tInput().Placeholder(\"type here...\"),\n\t),\n).NoCounts().Handle(\"\u003cC-s\u003e\", func() {\n\tname = name + \" saved\"\n}).Handle(\"escape\", func() {\n\tapp.Go(\"home\")\n})"
        }
      ]
    }
  ],
  "funcs": [
    {
      "name": "Arrange",
      "doc": "Arrange creates a container with a custom layout function.\nThe layout function receives child sizes and available space, returns positions.\n\n\tArrange(Grid(3, 20, 5))(\n\t    Text(\"A\"), Text(\"B\"), Text(\"C\"),\n\t    Text(\"D\"), Text(\"E\"), Text(\"F\"),\n\t)\n",
      "signature": "func Arrange(layout LayoutFunc) func(children ...any) Box",
      "examples": [
        {
          "doc": "Custom layout.\nArrange lets you define a fully custom layout function. It receives child sizes and available space, returns rects.\n",
          "code": "grid := Arrange(func(children []ChildSize, w, h int) []Rect {\n\tcols := 3\n\tcellW := w / cols\n\trects := make([]Rect, len(children))\n\tfor i := range children {\n\t\trects[i] = Rect{\n\t\t\tX: (i % cols) * cellW,\n\t\t\tY: (i / cols) * 2,\n\t\t\tW: cellW,\n\t\t\tH: 2,\n\t\t}\n\t}\n\treturn rects\n})\n\ngrid(Text(\"a\"), Text(\"b\"), Text(\"c\"))"
        }
      ]
    },
    {
      "name": "Bar",
      "doc": "Bar returns a segmented bar: ▮▮▮▯▯\n",
      "signature": "func Bar(filled, total int) string"
    },
    {
      "name": "BarBracket",
      "doc": "BarBracket returns a bracketed bar: [▮▮▮▯▯]\n",
      "signature": "func BarBracket(filled, total int) string"
    },
    {
      "name": "Define",
      "doc": "Define creates a scoped block for local component helpers and styles.\nThe function runs once at compile time (when SetView is called).\nPointers inside still provide dynamic values at render time.\n\n\tapp.SetView(\n\t    Define(func() any {\n\t        dot := func(ok *bool) any {\n\t            return If(ok).Then(Text(\"●\")).Else(Text(\"○\"))\n\t        }\n\t        return VBox(dot(\u0026a), dot(\u0026b), dot(\u0026c))\n\t    }),\n\t)\n",
      "signature": "func Define(fn func() any) any",
      "examples": [
        {
          "doc": "Scoped helpers.\nDefine scopes local helper functions inside the view tree. The function runs at build time and returns a component.\n",
          "code": "a, b, c := true, false, true\n\nDefine(func() any {\n\tdot := func(v *bool) any {\n\t\treturn If(v).Then(Text(\"●\").FG(Green)).Else(Text(\"○\").FG(Red))\n\t}\n\treturn HBox.Gap(1)(dot(\u0026a), dot(\u0026b), dot(\u0026c))\n})"
        }
      ]
    },
    {
      "name": "GenerateLabels",
      "doc": "GenerateLabels creates n unique labels for jump targets.\nFor small sets (\u003c=27): single chars (a, s, d, f, ...)\nFor larger sets: two chars (aa, as, ad, ...)\n",
      "signature": "func GenerateLabels(n int) []string"
    },
    {
      "name": "LED",
      "doc": "LED returns a single LED indicator: ● (on) or ○ (off)\n",
      "signature": "func LED(on bool) string"
    },
    {
      "name": "LEDs",
      "doc": "LEDs returns multiple LED indicators: ●●○○\n",
      "signature": "func LEDs(states ...bool) string"
    },
    {
      "name": "LEDsBracket",
      "doc": "LEDsBracket returns bracketed LED indicators: [●●○○]\n",
      "signature": "func LEDsBracket(states ...bool) string"
    },
    {
      "name": "LeaderDash",
      "doc": "LeaderDash creates a dash-leader string: \"LABEL-----------VALUE\"\n",
      "signature": "func LeaderDash(label, value string, width int) string"
    },
    {
      "name": "LeaderStr",
      "doc": "LeaderStr creates a dot-leader string: \"LABEL...........VALUE\"\nWidth is the total width including label and value.\nDeprecated: Use the Leader component for pointer binding support.\n",
      "signature": "func LeaderStr(label, value string, width int) string"
    },
    {
      "name": "Meter",
      "doc": "Meter returns an analog-style meter: ├──●──────┤\n",
      "signature": "func Meter(value, max, width int) string"
    },
    {
      "name": "TimingString",
      "doc": "TimingString returns a formatted timing string.\n",
      "signature": "func TimingString() string"
    },
    {
      "name": "VEmail",
      "doc": "VEmail rejects strings that don't look like email addresses.\n",
      "signature": "func VEmail(s string) error"
    },
    {
      "name": "VRequired",
      "doc": "VRequired rejects empty strings.\n",
      "signature": "func VRequired(s string) error"
    },
    {
      "name": "VTrue",
      "doc": "VTrue rejects false values.\n",
      "signature": "func VTrue(b bool) error"
    }
  ],
  "consts": [
    {
      "doc": "Box drawing characters for borders.\n",
      "names": [
        "BoxHorizontal",
        "BoxVertical",
        "BoxTopLeft",
        "BoxTopRight",
        "BoxBottomLeft",
        "BoxBottomRight",
        "BoxRoundedTopLeft",
        "BoxRoundedTopRight",
        "BoxRoundedBottomLeft",
        "BoxRoundedBottomRight",
        "BoxDoubleHorizontal",
        "BoxDoubleVertical",
        "BoxDoubleTopLeft",
        "BoxDoubleTopRight",
        "BoxDoubleBottomLeft",
        "BoxDoubleBottomRight"
      ],
      "decl": "const (\n\tBoxHorizontal         = '─'\n\tBoxVertical           = '│'\n\tBoxTopLeft            = '┌'\n\tBoxTopRight           = '┐'\n\tBoxBottomLeft         = '└'\n\tBoxBottomRight        = '┘'\n\tBoxRoundedTopLeft     = '╭'\n\tBoxRoundedTopRight    = '╮'\n\tBoxRoundedBottomLeft  = '╰'\n\tBoxRoundedBottomRight = '╯'\n\tBoxDoubleHorizontal   = '═'\n\tBoxDoubleVertical     = '║'\n\tBoxDoubleTopLeft      = '╔'\n\tBoxDoubleTopRight     = '╗'\n\tBoxDoubleBottomLeft   = '╚'\n\tBoxDoubleBottomRight  = '╝'\n)"
    },
    {
      "doc": "Box junction characters for merged borders\n",
      "names": [
        "BoxTeeDown",
        "BoxTeeUp",
        "BoxTeeRight",
        "BoxTeeLeft",
        "BoxCross"
      ],
      "decl": "const (\n\tBoxTeeDown  = '┬' // ─ meets │ from below\n\tBoxTeeUp    = '┴' // ─ meets │ from above\n\tBoxTeeRight = '├' // │ meets ─ from right\n\tBoxTeeLeft  = '┤' // │ meets ─ from left\n\tBoxCross    = '┼' // all four directions\n)"
    }
  ],
  "vars": [
    {
      "doc": "Debug timing\n",
      "names": [
        "DebugTiming",
        "DebugFullRedraw",
        "DebugFlush"
      ],
      "decl": "var (\n\tDebugTiming     bool\n\tDebugFullRedraw bool // force full redraws instead of diff-based (set TUI_FULL_REDRAW=1 to enable)\n\tDebugFlush      bool // dump flush debug info (set TUI_DEBUG_FLUSH=1 to enable)\n\n)"
    },
    {
      "doc": "Standard border styles.\n",
      "names": [
        "BorderSingle",
        "BorderRounded",
        "BorderDouble"
      ],
      "decl": "var (\n\tBorderSingle = BorderStyle{\n\t\tHorizontal:  BoxHorizontal,\n\t\tVertical:    BoxVertical,\n\t\tTopLeft:     BoxTopLeft,\n\t\tTopRight:    BoxTopRight,\n\t\tBottomLeft:  BoxBottomLeft,\n\t\tBottomRight: BoxBottomRight,\n\t}\n\tBorderRounded = BorderStyle{\n\t\tHorizontal:  BoxHorizontal,\n\t\tVertical:    BoxVertical,\n\t\tTopLeft:     BoxRoundedTopLeft,\n\t\tTopRight:    BoxRoundedTopRight,\n\t\tBottomLeft:  BoxRoundedBottomLeft,\n\t\tBottomRight: BoxRoundedBottomRight,\n\t}\n\tBorderDouble = BorderStyle{\n\t\tHorizontal:  BoxDoubleHorizontal,\n\t\tVertical:    BoxDoubleVertical,\n\t\tTopLeft:     BoxDoubleTopLeft,\n\t\tTopRight:    BoxDoubleTopRight,\n\t\tBottomLeft:  BoxDoubleBottomLeft,\n\t\tBottomRight: BoxDoubleBottomRight,\n\t}\n)"
    },
    {
      "doc": "Standard basic colours for convenience.\n",
      "names": [
        "Black",
        "Red",
        "Green",
        "Yellow",
        "Blue",
        "Magenta",
        "Cyan",
        "White",
        "BrightBlack",
        "BrightRed",
        "BrightGreen",
        "BrightYellow",
        "BrightBlue",
        "BrightMagenta",
        "BrightCyan",
        "BrightWhite"
      ],
      "decl": "var (\n\tBlack   = BasicColor(0)\n\tRed     = BasicColor(1)\n\tGreen   = BasicColor(2)\n\tYellow  = BasicColor(3)\n\tBlue    = BasicColor(4)\n\tMagenta = BasicColor(5)\n\tCyan    = BasicColor(6)\n\tWhite   = BasicColor(7)\n\n\t// Bright variants\n\tBrightBlack   = BasicColor(8)\n\tBrightRed     = BasicColor(9)\n\tBrightGreen   = BasicColor(10)\n\tBrightYellow  = BasicColor(11)\n\tBrightBlue    = BasicColor(12)\n\tBrightMagenta = BasicColor(13)\n\tBrightCyan    = BasicColor(14)\n\tBrightWhite   = BasicColor(15)\n)"
    },
    {
      "doc": "DefaultJumpStyle is the default styling for jump labels.\n",
      "names": [
        "DefaultJumpStyle"
      ],
      "decl": "var DefaultJumpStyle = JumpStyle{\n\tLabelStyle: Style{FG: Magenta, Attr: AttrBold},\n}"
    },
    {
      "doc": "SpinnerBraille is the default spinner animation (braille dots).\n",
      "names": [
        "SpinnerBraille"
      ],
      "decl": "var SpinnerBraille = []string{\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"}"
    },
    {
      "doc": "SpinnerCircle is a circle spinner.\n",
      "names": [
        "SpinnerCircle"
      ],
      "decl": "var SpinnerCircle = []string{\"◐\", \"◓\", \"◑\", \"◒\"}"
    },
    {
      "doc": "SpinnerDots is a simple dot spinner.\n",
      "names": [
        "SpinnerDots"
      ],
      "decl": "var SpinnerDots = []string{\"⣾\", \"⣽\", \"⣻\", \"⢿\", \"⡿\", \"⣟\", \"⣯\", \"⣷\"}"
    },
    {
      "doc": "SpinnerLine is a line spinner.\n",
      "names": [
        "SpinnerLine"
      ],
      "decl": "var SpinnerLine = []string{\"-\", \"\\\\\", \"|\", \"/\"}"
    },
    {
      "doc": "ThemeDark is a dark theme with light text on dark background.\n",
      "names": [
        "ThemeDark"
      ],
      "decl": "var ThemeDark = ThemeEx{\n\tBase:   Style{FG: White},\n\tMuted:  Style{FG: BrightBlack},\n\tAccent: Style{FG: BrightCyan},\n\tError:  Style{FG: BrightRed},\n\tBorder: Style{FG: BrightBlack},\n}"
    },
    {
      "doc": "ThemeLight is a light theme with dark text on light background.\n",
      "names": [
        "ThemeLight"
      ],
      "decl": "var ThemeLight = ThemeEx{\n\tBase:   Style{FG: Black},\n\tMuted:  Style{FG: BrightBlack},\n\tAccent: Style{FG: Blue},\n\tError:  Style{FG: Red},\n\tBorder: Style{FG: White},\n}"
    },
    {
      "doc": "ThemeMonochrome is a minimal theme using only attributes.\n",
      "names": [
        "ThemeMonochrome"
      ],
      "decl": "var ThemeMonochrome = ThemeEx{\n\tBase:   Style{},\n\tMuted:  Style{Attr: AttrDim},\n\tAccent: Style{Attr: AttrBold},\n\tError:  Style{Attr: AttrBold | AttrUnderline},\n\tBorder: Style{Attr: AttrDim},\n}"
    }
  ]
}
